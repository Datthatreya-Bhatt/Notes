#### What is nodejs ? what is its advantages ?
**What is Node.js?**
Node.js is a runtime environment that allows you to run JavaScript code outside of a web browser, typically used for building fast and scalable server-side applications.

**5 Advantages of Node.js:**

1. **Fast Performance** – Built on Google’s V8 engine, it executes code quickly.
2. **Non-blocking I/O** – Handles multiple requests at once using asynchronous programming.
3. **Single Programming Language** – Use JavaScript for both frontend and backend.
4. **Large Ecosystem** – Thousands of reusable packages available via npm.
5. **Scalability** – Ideal for building scalable network applications.
---

#### What is module.exports ?
module.exports is a special object in Node.js used to export functions, objects, or values from a file so they can be used in other files with require().
---

#### What is the difference between require and import ?

**`require`** is used in Node.js with the CommonJS module system. It loads modules at runtime, meaning the code runs when it's needed. It's older and works well in most Node.js environments.

**`import`** comes from modern JavaScript (ES6) and is used with ES modules. It loads modules at the beginning (statically) and supports features like tree shaking for better performance in bundlers.

So, in short:

* Use **`require`** in older or traditional Node.js projects.
* Use **`import`** in modern JavaScript or when using ES modules.

---

#### What is CORS and Why we need CORS ?
**What is CORS?**  
CORS (Cross-Origin Resource Sharing) is a security feature in web browsers that controls how resources are shared between different domains.

**Why we need CORS?**  
We need CORS to allow or restrict web pages from making requests to a different domain (cross-origin), helping protect users from malicious websites accessing sensitive data. It enables safe communication between frontend and backend hosted on different domains.

Want an example of a CORS error and how to fix it?
---

#### What are default exports ?
Default exports allow you to export a single value or function from a module so it can be imported without using curly braces, With default exports, you can import them using any name you like.

#### Explain event loop in node.

You're on the right track! Here's a **simple and clear explanation** of how the **Node.js event loop** works, filling in the gaps you're unsure about:

---

### 🔁 **What is the Event Loop?**

The **event loop** is a loop that runs continuously, checking if there’s any work to do (like executing callbacks). It helps Node.js manage **asynchronous tasks** without blocking the main thread.

---

### 🧠 Key Concepts

#### 1. **Call Stack**

* Executes **synchronous code** one by one.
* When it encounters **async tasks** (e.g., `setTimeout`, `fs.readFile`, `Promise`), it hands them off to **Node APIs** or the **libuv library** to handle in the background.

#### 2. **Queues**

* There are several **phase-based queues**:

  * **Timers Phase**: Runs `setTimeout` and `setInterval` callbacks.
  * **Pending Callbacks**: For some I/O callbacks.
  * **Poll Phase**: Retrieves new I/O events.
  * **Check Phase**: Runs `setImmediate()` callbacks.
  * **Close Callbacks**: For things like `socket.on('close')`.

* There is also a **microtask queue**, which includes:

  * `Promise.then/catch/finally`
  * `queueMicrotask`

---

### 🔄 How it Works (Simplified Loop)

```plaintext
1. Start event loop cycle
2. Run all code in the Call Stack
3. Then:
   - Go to Timers Phase → run some timer callbacks
   - Run all microtasks (empty the microtask queue)
   - Go to I/O callbacks Phase
   - Run all microtasks
   - Go to Poll Phase
   - Run all microtasks
   - Go to Check Phase
   - Run all microtasks
   - Go to Close Callbacks Phase
   - Run all microtasks
4. Repeat
```

---

### ❗ How Many Tasks Are Run?

* **From each phase queue**: Node runs **all callbacks that are ready**, or a **limited number** depending on internal behavior (not strictly documented), to prevent one phase from hogging the CPU.
* **From microtask queue**: Node **always drains the entire microtask queue** after each phase.

💡 This is why if you keep queuing microtasks (e.g., `while(true) Promise.resolve().then(...)`), the event loop can **starve the other phases** and freeze.

---

### 📌 Summary

* **Each phase has its own queue.**
* **Microtask queue is always fully drained after each phase.**
* **The loop repeats endlessly** as long as there are tasks or events.

---

Would you like a visual diagram of this process?


The **event loop** in **Node.js** works similarly to JavaScript in the browser but with some differences due to Node.js's ability to handle I/O operations and server-side tasks. 

### Key Phases of the Event Loop in Node.js:
Node.js has a **phased event loop** that helps manage asynchronous operations efficiently. Here’s how it works:

1. **Timers Phase**: 
   - Executes callbacks for `setTimeout()` and `setInterval()`.
   - Callbacks that are scheduled with a delay (e.g., `setTimeout()` with a 0ms delay) are executed here once the specified time has passed.

2. **I/O Callbacks Phase**: 
   - Executes most of the I/O callbacks, except for the ones handled in other phases like timers and `setImmediate()`.
   - This includes things like network events, file system operations, etc.

3. **Idle, Prepare Phase**:
   - Node.js prepares for the next phase.
   - It's mostly an internal phase and doesn't deal with user code.

4. **Poll Phase**:
   - The event loop waits for incoming I/O events (like file reads, network requests).
   - If there are I/O events, it processes them and executes their callbacks.
   - If there are no I/O events, Node.js will check if there are any `setImmediate()` callbacks waiting and will move to the **check phase**.

5. **Check Phase**:
   - Executes callbacks for `setImmediate()` (callbacks scheduled to run immediately after the poll phase).
   
6. **Close Callbacks Phase**:
   - Executes callbacks for closed connections, like when a socket is closed (`socket.on('close', ...)`).

---

### Example:

```javascript
console.log("Start");

setTimeout(() => {
  console.log("Timeout");
}, 0);

setImmediate(() => {
  console.log("Immediate");
});

process.nextTick(() => {
  console.log("Next Tick");
});

console.log("End");
```

**Execution Flow**:
1. `console.log("Start")` is printed.
2. `setTimeout()` callback is placed in the **Timers Phase** (scheduled to execute after 0ms).
3. `setImmediate()` callback is placed in the **Check Phase** (scheduled to execute immediately after the poll phase).
4. `process.nextTick()` is placed in the **Next Tick Queue** and will be executed immediately after the current operation completes, before any other asynchronous callbacks.
5. `console.log("End")` is printed.
6. `process.nextTick()` callback is executed, printing **Next Tick**.
7. The event loop then goes to the **Timers Phase** and executes the `setTimeout()` callback, printing **Timeout**.
8. Finally, the event loop reaches the **Check Phase** and executes the `setImmediate()` callback, printing **Immediate**.

**Output**:
```
Start
End
Next Tick
Timeout
Immediate
```

---

### Summary of Event Loop Phases in Node.js:

1. **Timers**: Executes `setTimeout()` and `setInterval()` callbacks.
2. **I/O Callbacks**: Handles most I/O callbacks (excluding timers and immediate).
3. **Idle, Prepare**: Internal phase for Node.js to prepare the loop.
4. **Poll**: Waits for and processes I/O events; checks if `setImmediate()` callbacks need to run.
5. **Check**: Executes `setImmediate()` callbacks.
6. **Close Callbacks**: Handles callbacks for closed connections (e.g., socket closures).

### Why the Event Loop Matters in Node.js:
- **Non-blocking I/O**: The event loop ensures that Node.js can handle thousands of concurrent connections efficiently without blocking the main thread.
- **Asynchronous Processing**: It allows Node.js to perform I/O operations like reading files or making network requests without stopping the execution of other code.

---





#### What is expressJS ?
Express.js is a lightweight and fast web application framework for Node.js that helps build web servers and APIs easily. It simplifies tasks like routing, handling requests, and managing middleware in server-side JavaScript applications.


#### Nodejs is single thread or multi thread ?
**Node.js is single-threaded** by default, using a single main thread to handle requests.
However, it uses **non-blocking I/O** and a **thread pool in the background** (via the libuv library) to perform tasks like file I/O or encryption in a multi-threaded way.
So, it's **single-threaded in design**, but can use **multiple threads under the hood** for certain operations.



#### If node js is single thread how does it handles concurrency ?
Node.js handles concurrency using an **event-driven, non-blocking I/O model**.

Even though it's single-threaded, Node.js can manage multiple tasks concurrently by delegating I/O operations (like reading files or querying a database) to the system's kernel, which handles them in the background. While waiting for these tasks to complete, Node.js can continue executing other code, thus preventing the main thread from being blocked.

This approach allows Node.js to handle many requests efficiently, without needing multiple threads.



#### What are the different HTTP methods, Simply explain when to use it ?

1. **GET** – Used to **retrieve data** from the server.
   **Use it** when you want to fetch resources (like a webpage or data).

2. **POST** – Used to **send data** to the server, often to create or update something.
   **Use it** when submitting form data or creating a new resource.

3. **PUT** – Used to **update a resource** completely on the server.
   **Use it** when you want to replace an existing resource with new data.

4. **PATCH** – Used to **partially update a resource**.
   **Use it** when you only need to update some fields of a resource, not the whole thing.

5. **DELETE** – Used to **delete a resource** on the server.
   **Use it** when you want to remove something from the server.

6. **HEAD** – Similar to GET, but it only retrieves the **headers** without the body.
   **Use it** to check if a resource exists or to get metadata.

7. **OPTIONS** – Used to **retrieve allowed HTTP methods** for a resource.
   **Use it** to see which methods the server supports for a particular URL.




#### What are middlewares and what does next() function do ?
Middleware in Express.js are functions that have access to the request, response, and the next function in the request-response cycle. They are used to modify the request or response, or to end the request-response cycle.

next() is a function used to pass control to the next middleware function in the stack. If you don't call next(), the request will hang and won't proceed to the next middleware or route handler.

What next() does:
It moves the request to the next middleware in line or to the route handler if no more middleware is left.


#### Which module is used to read and write operations in a file?
fs module is used to read and write operations in a file


#### What are the some flags used in read/write operations in files ?

1. **`r`** – Open file for reading. If the file doesn't exist, it throws an error.
2. **`w`** – Open file for writing. If the file doesn't exist, it is created. If it exists, it is overwritten.
3. **`a`** – Open file for appending. If the file doesn't exist, it is created. If it exists, data is added at the end.
4. **`r+`** – Open file for both reading and writing. The file must exist.
5. **`w+`** – Open file for reading and writing. If the file doesn't exist, it is created, and if it exists, it's overwritten.
6. **`a+`** – Open file for both reading and appending. If the file doesn't exist, it is created.



#### What are web servers? How are they different from your laptop
**Web servers** are software or hardware that handle requests from clients (like browsers), process those requests, and return the appropriate responses, usually in the form of web pages.


**Difference from your laptop**:

* A **web server** is specifically designed to handle incoming web traffic and serve content efficiently to many users.
* Your **laptop** is a general-purpose machine used for personal tasks and does not serve web content by default. While it can function as a web server (using software like XAMPP or Node.js), it's not optimized for handling large-scale web traffic.



#### How do you do error logging in your application?
For simple logging, you can use console.log() or console.error() to print messages to the console. For more advanced logging, use libraries like Winston or Morgan.


#### What is a jwt token ? How do you create a jwt token?
**What is a JWT Token?**
JWT (JSON Web Token) is a compact, URL-safe token format used to securely transmit information between parties as a JSON object. It is commonly used for authentication and authorization.

A JWT typically consists of three parts:

1. **Header** – Contains the algorithm and token type.
2. **Payload** – Contains the claims (data or information).
3. **Signature** – Ensures the token hasn’t been tampered with.

**How to Create a JWT Token?**
To create a JWT token, you can use a library like `jsonwebtoken` in Node.js.

Steps:

1. Install the `jsonwebtoken` library:

   ```bash
   npm install jsonwebtoken
   ```

2. Create a JWT token:

   ```js
   const jwt = require('jsonwebtoken');

   // Create a token
   const token = jwt.sign({ userId: 123 }, 'your_secret_key', { expiresIn: '1h' });

   console.log(token);  // This is your JWT token
   ```

* **Payload**: Contains the data (like `userId`).
* **Secret Key**: A secret string used to sign the token.
* **Expiration**: Defines how long the token is valid (optional).



#### What is the use of pm2 ? What advantage does it give?
**What is PM2?**
PM2 is a process manager for Node.js applications. It helps you run and manage your applications in the background, keeping them alive and handling issues like crashes.

**Advantages of PM2:**

1. **Automatic Restart**: PM2 automatically restarts your app if it crashes or stops unexpectedly.
2. **Load Balancing**: It can run multiple instances of your app across different CPU cores to improve performance.
3. **Process Monitoring**: PM2 allows you to monitor app performance and resource usage (e.g., CPU and memory).
4. **Log Management**: It handles and stores logs for easy access and debugging.
5. **Easy Deployment**: You can deploy applications with ease using PM2’s built-in features like "pm2 deploy."

PM2 helps in maintaining app uptime and makes managing production environments easier.



#### What are the different pm2 commands that you have used?
Here’s a list of useful PM2 commands and their uses:

1. **Start an app**
   `pm2 start <app.js>`
   Starts a Node.js application. You can also specify the number of instances:
   `pm2 start app.js -i 4` (4 instances)

2. **List all running apps**
   `pm2 list`
   Displays all the applications running under PM2.

3. **Monitor application performance**
   `pm2 monit`
   Opens a real-time monitoring dashboard for CPU and memory usage of your apps.

4. **Stop an app**
   `pm2 stop <app_name|id>`
   Stops a specific application.

5. **Restart an app**
   `pm2 restart <app_name|id>`
   Restarts a specific application. Can be used for updates or recovering from crashes.

6. **Delete an app**
   `pm2 delete <app_name|id>`
   Removes an app from PM2’s process list.

7. **Show logs**
   `pm2 logs`
   Displays the logs for all running applications.
   `pm2 logs <app_name|id>` shows logs for a specific app.

8. **Save the process list**
   `pm2 save`
   Saves the current list of processes so that PM2 can restore them after a reboot.

9. **Startup script**
   `pm2 startup`
   Generates a startup script to ensure PM2 and your apps restart automatically on system reboot.

10. **Generate a dump of all processes**
    `pm2 dump`
    Saves the current app states to a JSON file, which can be restored later.

11. **View detailed app info**
    `pm2 show <app_name|id>`
    Displays detailed information about a specific application, like memory usage and uptime.

12. **Reload apps (without downtime)**
    `pm2 reload <app_name|id>`
    Reloads the app with zero downtime (useful for updating code).



#### What is the use package json file?
The package.json file is used in Node.js projects to manage metadata about the project and its dependencies.
Key uses of package.json:

- Project Information: It includes the project’s name, version, description, and author.

- Dependencies: Lists all the libraries (like Express, lodash, etc.) that the project depends on, so they can be installed automatically using npm install.

- Scripts: Defines commands (like npm start, npm test) to run tasks like starting the server, running tests, or building the project.

- Version Management: Specifies the versions of packages that are compatible with your project.

- Configuration: Stores configuration for tools like linters or test runners.



#### What is the use of packageLock.json? Why do we even need it?
`package-lock.json` is automatically generated when you run `npm install`. It locks the exact versions of the dependencies (and their sub-dependencies) that were installed, ensuring consistency across different environments or machines.

**Why do we need it?**

1. **Consistency**: Ensures that every developer or server uses the exact same versions of dependencies, preventing version conflicts.
2. **Faster installs**: Speeds up the installation process by providing a precise dependency tree.
3. **Security**: Helps avoid issues caused by accidental upgrades or mismatches in dependencies.



#### What is the difference between dependencies and devdependencies in package.json? When to use what?
In `package.json`, **dependencies** and **devDependencies** are used to manage packages that your project needs.

1. **`dependencies`**:
   These are the packages your project needs to run in production (e.g., frameworks like Express, utility libraries like Lodash).
   **Use it for**: Libraries or tools that are necessary for your app to function.

  
2. **`devDependencies`**:
   These are the packages you need only during development (e.g., testing libraries, build tools). They are not necessary in production environments.
   **Use it for**: Tools like testing frameworks, compilers, or linters that are only used in development.




#### What are some commonly used timing features of Node.js?
Some commonly used timing features in Node.js are:

1. **`setTimeout()`**:
   Executes a function after a specified delay (in milliseconds).

   ```js
   setTimeout(() => {
     console.log("Hello after 2 seconds");
   }, 2000);
   ```

2. **`setInterval()`**:
   Repeatedly executes a function at specified intervals (in milliseconds).

   ```js
   setInterval(() => {
     console.log("This runs every 3 seconds");
   }, 3000);
   ```

3. **`clearTimeout()`**:
   Stops a function from executing after a delay, if it's been set using `setTimeout()`.

   ```js
   const timeoutId = setTimeout(() => { console.log("This won't run"); }, 5000);
   clearTimeout(timeoutId);
   ```

4. **`clearInterval()`**:
   Stops a function from executing at intervals, if it's been set using `setInterval()`.

   ```js
   const intervalId = setInterval(() => { console.log("This won't repeat"); }, 2000);
   clearInterval(intervalId);
   ```



#### What is fork in node JS?
In Node.js, **`fork()`** is a method used to create a new **child process** that runs a separate instance of the Node.js script. It's a part of the **`child_process`** module.

**Key points about `fork()`**:

* It allows you to run multiple processes in parallel, which is useful for CPU-intensive tasks.
* Each child process has its own memory space, but they can communicate with the parent process through **IPC (Inter-Process Communication)**.
* **`fork()`** is mainly used for **multi-core** systems to utilize all CPU cores for better performance.

**Example**:

```js
const { fork } = require('child_process');

const child = fork('childScript.js'); // Fork a new child process

child.on('message', (msg) => {
  console.log('Message from child:', msg);
});

child.send('Hello, child!');
```

**Use case**: It’s used to handle tasks like parallelizing computation-heavy tasks without blocking the main thread.


#### Give me list of all the highly used methods from child_process package with their use

1. **`fork()`**

   * **Use**: Creates a new child process that runs a JavaScript file.
   * **Example**:

     ```js
     const { fork } = require('child_process');
     const child = fork('childScript.js');
     ```

2. **`spawn()`**

   * **Use**: Launches a new process with a given command and arguments. It gives you more control over the process's input/output streams.
   * **Example**:

     ```js
     const { spawn } = require('child_process');
     const ls = spawn('ls', ['-lh', '/usr']);
     ls.stdout.on('data', (data) => {
       console.log(`stdout: ${data}`);
     });
     ```

3. **`exec()`**

   * **Use**: Runs a command in a shell and buffers the output. It’s ideal for commands where you expect a small output.
   * **Example**:

     ```js
     const { exec } = require('child_process');
     exec('ls -lh', (error, stdout, stderr) => {
       if (error) {
         console.error(`exec error: ${error}`);
         return;
       }
       console.log(`stdout: ${stdout}`);
     });
     ```

4. **`execFile()`**

   * **Use**: Runs a file directly without going through the shell, useful for executing non-shell commands or scripts.
   * **Example**:

     ```js
     const { execFile } = require('child_process');
     execFile('myScript.sh', ['arg1', 'arg2'], (error, stdout, stderr) => {
       if (error) {
         console.error(`execFile error: ${error}`);
         return;
       }
       console.log(`stdout: ${stdout}`);
     });
     ```

5. **`spawnSync()`**

   * **Use**: Synchronously runs a command and returns the result, blocking the Node.js event loop.
   * **Example**:

     ```js
     const { spawnSync } = require('child_process');
     const result = spawnSync('ls', ['-lh']);
     console.log(`stdout: ${result.stdout.toString()}`);
     ```

6. **`execSync()`**

   * **Use**: Synchronously runs a command and returns the output, useful for small commands but blocks the event loop.
   * **Example**:

     ```js
     const { execSync } = require('child_process');
     const output = execSync('ls -lh');
     console.log(output.toString());
     ```




#### What is child process in nodejs
A **child process** in Node.js refers to a **separate process** that is created by the main (parent) process to perform specific tasks.

### **What it does:**

* It allows your Node.js application to run multiple processes simultaneously, which is useful for tasks like **file operations**, **heavy computation**, or **running external scripts**.
* The child process can communicate with the parent process via **IPC (Inter-Process Communication)**.

### **Why it's useful:**

* Node.js is single-threaded, but with child processes, you can **parallelize tasks** and improve performance.
* It helps avoid blocking the event loop, making your app more efficient.

### **Example:**

```js
const { spawn } = require('child_process');

// Create a child process to run a command (e.g., 'ls' to list directory)
const child = spawn('ls', ['-l']);

child.stdout.on('data', (data) => {
  console.log(`Child process output: ${data}`);
});

child.stderr.on('data', (data) => {
  console.error(`Child process error: ${data}`);
});
```

### **Why we use it:**

* It helps in executing tasks outside the Node.js process, like running system commands or managing multiple operations.




#### What is cluster in nodejs ?
**Cluster** in Node.js is a module that allows you to create **multiple child processes** (workers) that can share the same server port, taking advantage of multi-core systems to handle concurrent requests more efficiently.

### **What it does:**

* It helps Node.js handle **more traffic** by creating **multiple instances** of your app, each running on a different core of your CPU.
* The **master process** controls the workers, which share the same server port.

### **Why it's useful:**

* Node.js is single-threaded, but clustering allows you to **scale** your application to utilize multiple CPU cores, improving performance and load balancing.

### **Example:**

```js
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  // Fork workers
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
} else {
  // Worker processes have a HTTP server
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end('Hello from worker!');
  }).listen(8000);
}
```

### **Why use it:**

* **Improves performance** by using multiple cores.
* Helps your app **handle more requests** simultaneously.




#### What is spawn in nodeJS ?
**`spawn()`** is a method in Node.js's **child\_process** module that is used to **create a new process** (child process) and **execute a command** in a separate process. It’s commonly used to run system commands or execute other scripts.

### **What it does:**

* It launches a new process asynchronously and provides streams (stdin, stdout, stderr) to interact with the process.
* Unlike `exec()`, which buffers the output, `spawn()` gives you a **streaming output**, making it more efficient for large outputs.

### **Why it's useful:**

* It's ideal for running commands or scripts where you want to handle large amounts of data without blocking your Node.js app.

### **Example:**

```js
const { spawn } = require('child_process');

// Spawn a new process to run the 'ls' command
const child = spawn('ls', ['-l']);

// Listen to the output (stdout) from the command
child.stdout.on('data', (data) => {
  console.log(`Output: ${data}`);
});

// Listen to any errors (stderr) from the command
child.stderr.on('data', (data) => {
  console.error(`Error: ${data}`);
});
```

### **Why use it:**

* For running system-level commands or scripts without blocking the event loop.
* Efficient when handling large outputs.




#### What is the difference between fork and child process ?
In Node.js, both **`fork()`** and **`child_process`** are used to create new processes, but they are used in slightly different ways.

### **`fork()`**:

* **Specialized version of `spawn()`** used to create new **child processes** specifically for **Node.js applications**.
* It is used to run **Node.js scripts** in parallel and allows **communication between parent and child** via IPC (Inter-Process Communication).
* **Best for creating Node.js worker processes**.

### **`child_process`**:

* A general module that can be used to create new processes in Node.js using methods like **`spawn()`**, **`exec()`**, and **`fork()`**.
* It can execute any system command or run scripts, not just Node.js scripts.

### **Key Differences**:

* **`fork()`** is a specific method in the **`child_process`** module to create child processes for Node.js applications, with built-in IPC support for communication between parent and child processes.
* **`child_process`** is the overall module that provides various methods (`spawn()`, `exec()`, `fork()`) to create and manage child processes.

### **Example**:

```js
const { fork } = require('child_process');

// Fork a new Node.js process
const child = fork('childScript.js');

child.on('message', (msg) => {
  console.log(`Message from child: ${msg}`);
});

child.send('Hello, child!');
```

**When to use which:**

* Use **`fork()`** when you want to run another Node.js script and need communication between the processes.
* Use **`spawn()`** or **`exec()`** when you want to run system-level commands or external scripts.




#### What is node.js streams?
**Node.js Streams** are objects used to handle reading or writing data in a **continuous and efficient manner**. They allow you to process data in **chunks** rather than loading everything into memory at once, making them ideal for handling large amounts of data (like files, HTTP requests, or network connections).

### **Types of Streams:**

1. **Readable Streams**: Used for reading data.

   * Example: `fs.createReadStream()` to read a file.
2. **Writable Streams**: Used for writing data.

   * Example: `fs.createWriteStream()` to write data to a file.
3. **Duplex Streams**: Can both read and write data.

   * Example: TCP sockets (network connections).
4. **Transform Streams**: A type of duplex stream where the data is modified as it's read and written.

   * Example: `zlib.createGzip()` to compress data.

### **Why Streams are useful:**

* **Efficient**: Process data without loading it all at once into memory.
* **Faster**: Allows for faster data processing because data can be consumed as it arrives.

### **Example of Readable Stream:**

```js
const fs = require('fs');

const readableStream = fs.createReadStream('file.txt');
readableStream.on('data', (chunk) => {
  console.log(`Received chunk: ${chunk}`);
});
```

### **Why use it:**

* It's ideal for handling large files, network requests, or continuous data streams where you don’t want to wait for everything to load.




#### What are node.js buffers?


**Node.js Buffers** are used to handle raw binary data in memory. They are especially useful when working with streams, files, and network data because they allow you to deal with binary data directly.

### **What it does:**

* A **Buffer** is a chunk of memory allocated outside of the V8 JavaScript engine (which runs Node.js) to store binary data.
* Buffers are needed because JavaScript normally handles data as **strings** (UTF-8), but for binary data like images, audio, or file content, Buffers provide a way to handle raw bytes.

### **Why Buffers are useful:**

* They allow you to work with raw data (e.g., reading from a file, sending binary data over a network) without needing to convert it into strings or objects.

### **Example of a Buffer:**

```js
const buf = Buffer.from('Hello, World!', 'utf-8');
console.log(buf);  // <Buffer 48 65 6c 6c 6f 2c 20 57 6f 72 6c 64 21>
```

This creates a buffer from the string `'Hello, World!'` in UTF-8 encoding.

### **Common Uses of Buffers:**

1. **File Handling**: Reading files as binary data.
2. **Network Communication**: Sending and receiving raw data (e.g., images, audio).
3. **Streams**: Buffers help process data in chunks without waiting for the entire stream to load.



#### Describe the 5 exit codes of Node.js?

1. **`0`** – **Successful execution**
   Indicates that the process completed successfully without any errors.

   ```js
   process.exit(0);  // Successful exit
   ```

2. **`1`** – **General errors**
   Used for general or unspecified errors, like when an exception is thrown and the process can't handle it.

   ```js
   process.exit(1);  // Unhandled error
   ```

3. **`2`** – **Misuse of shell built-in commands**
   Indicates that a command or argument passed to the shell was used incorrectly.

   ```js
   process.exit(2);  // Shell command error
   ```

4. **`128`** – **Invalid exit status**
   This exit code is used when the process is terminated due to an invalid exit status or by a signal.

   ```js
   process.exit(128);  // Invalid status
   ```

5. **`137`** – **Process killed by SIGKILL signal**
   The process was forcefully terminated by the `SIGKILL` signal (often due to memory or resource issues).

   ```js
   process.exit(137);  // Killed by SIGKILL
   ```




#### What is reactor and proactor pattern in nodeJS
**Reactor** and **Proactor** are design patterns used to handle I/O operations efficiently, especially in event-driven systems like Node.js. Here’s a simple explanation of both:

### **Reactor Pattern**:

* The **Reactor Pattern** is used to handle multiple concurrent I/O operations in a single-threaded, non-blocking way.
* It works by using an **event loop** to listen for events (like data arrival or I/O readiness) and dispatching the events to appropriate **handlers** (callbacks).
* Node.js itself follows this pattern with its event-driven architecture.

**Example in Node.js**:
When a network request comes in, the event loop picks it up and triggers the corresponding callback to handle the request. The I/O operation (e.g., reading from a file or database) doesn't block the thread, allowing other operations to proceed.

### **Proactor Pattern**:

* The **Proactor Pattern** is similar to the Reactor, but instead of the event loop waiting for events and then dispatching them, the system directly invokes the **completion handler** once the I/O operation is completed by an underlying system (like OS-level I/O operations).
* The main difference is that in Proactor, the system initiates the I/O operation, and when it completes, it automatically calls the appropriate handler.

**Proactor in Node.js**:
While Node.js is more aligned with the **Reactor pattern**, it can also exhibit **Proactor-like behavior** in some cases (especially in file system operations, where the OS handles the I/O and Node.js just responds when it's complete).

### In summary:

* **Reactor Pattern**: Node.js uses an event loop to manage and dispatch I/O events to handlers (callbacks).
* **Proactor Pattern**: The system itself invokes the callback once the I/O operation is completed by an external system (like OS).

Node.js generally follows the **Reactor Pattern**, but both patterns aim to make I/O operations non-blocking and efficient.



#### What is the purpose of NODE_ENV? Why do we even need the different environments like production and staging?
**`NODE_ENV`** is an environment variable in Node.js that specifies the current environment in which the application is running (e.g., development, production, staging). It helps control how the application behaves in different stages of the development cycle.

### **Purpose of `NODE_ENV`**:
- It allows the app to behave differently depending on the environment (e.g., enabling logging or debugging in development, and optimizing for performance in production).
- It helps in loading environment-specific configurations, settings, and values.

### **Why do we need different environments like `production` and `staging`?**:

1. **`development`**:  
   - Used when actively building or working on the app.
   - Features like debugging, logging, and detailed error messages are enabled.
   - It’s not optimized for performance.

2. **`staging`**:  
   - A testing environment that mimics the production environment.
   - Used to test new features or versions before deploying them to production.

3. **`production`**:  
   - Used when the app is live and being used by end-users.
   - Optimized for performance, with debugging and logging turned off or minimized.
   - Ensures stability and security of the app.

### Why different environments are needed:
- **Different configurations**: You may need different databases, API keys, or features for different environments.
- **Optimization**: In production, you want your app to be fast and stable, while in development, you focus on debugging and flexibility.
- **Testing**: Staging helps ensure new code or updates won’t break the live production app.

**Example** of setting `NODE_ENV`:
```js
if (process.env.NODE_ENV === 'production') {
  // production-specific code
} else {
  // development-specific code
}
```

This way, you can optimize and configure the app according to the environment it's running in.



#### What is MVC structure ?  Can you explain the role of Model,Views and Controller ?

**MVC (Model-View-Controller)** is a design pattern used to separate the concerns of an application, making it easier to manage and scale. It divides the application into three main components:

### **1. Model**:

* **Role**: Represents the data and business logic of the application. It interacts with the database or any data source to fetch, update, and store data.
* **Example**: A model could represent a "User" in your system, with methods to retrieve or modify user information from the database.

### **2. View**:

* **Role**: Represents the user interface (UI) of the application. It displays data from the model to the user and provides a way for the user to interact with the system.
* **Example**: A webpage showing the user's profile with their name, email, and profile picture is a view. It simply displays the data provided by the model.

### **3. Controller**:

* **Role**: Acts as an intermediary between the Model and the View. It processes user inputs (from the view), manipulates the data (via the model), and updates the view accordingly.
* **Example**: When a user submits a form to update their profile, the controller will handle the request, validate the data, update the model, and then refresh the view.

### **Summary**:

* **Model**: Handles data and logic.
* **View**: Displays data to the user.
* **Controller**: Manages input, updates the model, and updates the view.






#### What are the core modules of node js, simply explain their use ?
Node.js has several core modules that are built-in and can be used without any additional installation. Here are some of the key core modules and their uses:

### 1. **`http`**:

* **Use**: Allows you to create HTTP servers and make HTTP requests.
* **Example**: Used to handle web requests, like creating a web server.

```js
const http = require('http');
http.createServer((req, res) => {
  res.end('Hello, World!');
}).listen(3000);
```

### 2. **`fs` (File System)**:

* **Use**: Used for reading from and writing to files on your local file system.
* **Example**: Helps you read, write, and modify files.

```js
const fs = require('fs');
fs.readFile('example.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(data);
});
```

### 3. **`path`**:

* **Use**: Provides utilities for working with file and directory paths.
* **Example**: Helps with joining, resolving, and normalizing paths.

```js
const path = require('path');
const filePath = path.join(__dirname, 'folder', 'file.txt');
console.log(filePath);
```

### 4. **`os` (Operating System)**:

* **Use**: Provides information about the operating system, like memory, platform, etc.
* **Example**: Helps you get system information.

```js
const os = require('os');
console.log(os.platform());
console.log(os.totalmem());
```

### 5. **`events`**:

* **Use**: Provides the ability to work with event-driven programming and emit/handle events.
* **Example**: Useful for creating event-driven applications.

```js
const EventEmitter = require('events');
const emitter = new EventEmitter();
emitter.on('event', () => {
  console.log('An event occurred!');
});
emitter.emit('event');
```

### 6. **`util`**:

* **Use**: Provides utility functions like formatting strings and debugging.
* **Example**: Helps with debugging or formatting data.

```js
const util = require('util');
console.log(util.format('%s is %d years old', 'Alice', 25));
```

### 7. **`stream`**:

* **Use**: Provides a way to handle streaming data (e.g., reading/writing files, network communication).
* **Example**: Useful for large data or files that don’t fit into memory.

```js
const fs = require('fs');
const readStream = fs.createReadStream('file.txt');
readStream.on('data', (chunk) => {
  console.log('Reading chunk:', chunk);
});
```

### 8. **`process`**:

* **Use**: Provides information and control over the current Node.js process.
* **Example**: Helps handle command-line arguments or control the exit behavior.

```js
console.log(process.argv);  // Command-line arguments
```

### 9. **`buffer`**:

* **Use**: Deals with binary data directly, especially useful for handling raw memory.
* **Example**: Helps with manipulating raw binary data in streams or files.

```js
const buffer = Buffer.from('Hello');
console.log(buffer.toString());
```

### 10. **`crypto`**:

* **Use**: Provides cryptographic functionality such as hashing, encryption, and signing data.
* **Example**: Used for security-related operations like hashing passwords.

```js
const crypto = require('crypto');
const hash = crypto.createHash('sha256');
hash.update('password');
console.log(hash.digest('hex'));
```



#### What are relative path and absolute path? How to define them?
**Relative path** and **absolute path** are ways to locate files or directories in a file system.

### **Relative Path**:

* A **relative path** points to a file or folder **relative to the current directory** (usually `__dirname` in Node.js).
* **Does not start with `/` or drive letter**.
* **Example**:

  ```js
  const filePath = './folder/file.txt';  // relative to current file
  ```

### **Absolute Path**:

* An **absolute path** gives the **full path from the root directory**.
* Always starts from the system root (`/` on Linux/Mac or `C:/` on Windows).
* **Example in Node.js**:

  ```js
  const path = require('path');
  const filePath = path.join(__dirname, 'folder', 'file.txt'); // absolute path
  ```

### Summary:

* **Relative Path**: Depends on where the file is being run from.
* **Absolute Path**: Always points to the same location, no matter where the script runs from.




#### What does createServer do in express ?
In **Express**, `createServer` is **not used directly**. Instead, Express provides its own way to create a server using `express()` and `app.listen()`.

However, if you're referring to `http.createServer()`, here's a simple explanation:

### **`http.createServer()`** (in Node.js):

* It creates an HTTP server that can handle requests and send responses.
* Used in core Node.js, not Express.

**Example:**

```js
const http = require('http');
const server = http.createServer((req, res) => {
  res.end('Hello World');
});
server.listen(3000);
```

### In **Express**, you usually do:

```js
const express = require('express');
const app = express();
app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

So, **`createServer()`** is used in **plain Node.js**, while in **Express**, you typically use `app.listen()` which under the hood uses `http.createServer()`.




#### What do you think server.listens exactly do?Why do we need it?
The `server.listen()` method in Node.js or Express **starts the server** and makes it **listen for incoming requests** on a specified **port** and **host**.

### **What it does:**

* Binds the server to a **port** (like 3000 or 8080).
* Starts the **event loop** to handle client requests.

### **Why we need it:**

* Without `listen()`, the server won’t start.
* It tells the server to wait for and handle HTTP requests.

**Example:**

```js
const express = require('express');
const app = express();

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

Here, the server starts and is ready to respond to incoming requests on port 3000.



#### What does process.exit do?
`process.exit()` in Node.js **stops the application** immediately.

### **What it does:**

* Ends the Node.js process.
* You can optionally pass an **exit code**:

  * `0` = success
  * Any other number = error

### **Example:**

```js
console.log("App is running");
process.exit(0);  // Exits the program successfully
console.log("This will not run");
```

### **Why we use it:**

* To **manually end** the app (e.g., after a task finishes or an error occurs).



#### Explain all the status codes.
Here’s a **simple explanation of common HTTP status codes**, grouped by type:

---

### **1xx – Informational** (Request received, still processing)
- **100** – Continue  
- **101** – Switching Protocols

---

### **2xx – Success** (Request was successful)
- **200** – OK  
- **201** – Created (used after creating a resource)  
- **204** – No Content (successful but no response body)

---

### **3xx – Redirection** (Further action needed)
- **301** – Moved Permanently  
- **302** – Found (temporary redirect)  
- **304** – Not Modified (cached version is still valid)

---

### **4xx – Client Errors** (Problem with the request)
- **400** – Bad Request (invalid data)  
- **401** – Unauthorized (no valid auth)  
- **403** – Forbidden (no permission)  
- **404** – Not Found (URL doesn’t exist)  
- **409** – Conflict (e.g., duplicate data)  
- **429** – Too Many Requests (rate limit hit)

---

### **5xx – Server Errors** (Problem on the server)
- **500** – Internal Server Error  
- **501** – Not Implemented  
- **502** – Bad Gateway  
- **503** – Service Unavailable  
- **504** – Gateway Timeout

---



#### What is parsing
**Parsing** means **analyzing and converting data** (usually a string) into a format that a program can easily understand and work with.

### **Example:**

* Parsing JSON string into an object:

  ```js
  const data = JSON.parse('{"name": "Alice"}');
  console.log(data.name); // Output: Alice
  ```

### **Why it's needed:**
* Data from APIs or files often comes as text (like JSON or CSV), and parsing turns it into usable structures like objects or arrays.



#### What problem does nodemon solve ?
Nodemon solves the problem of manually restarting your Node.js server every time you make changes to your code.

#### When would you use --save-dev and --save?
You use `--save-dev` and `--save` (or just omit it) when installing npm packages, depending on **how the package is used**:

### **`--save-dev`**:

* Use for **development-only tools** (not needed in production).
* Examples: linters, test frameworks, build tools.
* Saved under `devDependencies` in `package.json`.

```bash
npm install eslint --save-dev
```

### **`--save`** (or default):

* Use for packages needed at **runtime** (when your app runs in production).
* Saved under `dependencies` in `package.json`.

```bash
npm install express --save
```

> Note: From npm v5 and up, `--save` is the default and can be omitted.



#### What is npm ?
**npm** stands for **Node Package Manager**.

### **What it does:**

* It's a **tool** used to **install, manage, and share** packages (libraries or modules) in Node.js projects.
* Comes **built-in with Node.js**.

### **Why it's useful:**

* Helps you add external code (like Express, Lodash, etc.) to your project.
* Manages dependencies in a file called `package.json`.

**Example usage:**

```bash
npm install express
```

This installs the **Express** library into your project.




#### WHat is JSON ?
**JSON** stands for **JavaScript Object Notation**.

### **What it is:**
- A **lightweight data format** used to store and exchange data.
- Based on **key-value pairs**, similar to JavaScript objects.

### **Why it's useful:**
- Easy to read and write.
- Used widely in **APIs**, **configuration files**, and **data storage**.

### **Example:**
```json
{
  "name": "Alice",
  "age": 25,
  "isStudent": false
}
```



#### What is the use of app.use ?
In **Express.js**, `app.use()` is used to **mount middleware** in your application. Middleware functions are executed in the order they are added and can modify requests and responses, or terminate the request-response cycle.

### **What it does:**

* It tells Express to **use** a function (middleware) for handling requests.
* It can be used for tasks like logging, authentication, parsing request bodies, etc.

### **Example:**

```js
const express = require('express');
const app = express();

// Middleware to log requests
app.use((req, res, next) => {
  console.log(`${req.method} ${req.url}`);
  next();  // Pass control to the next middleware
});

// Define a route
app.get('/', (req, res) => {
  res.send('Hello, World!');
});

app.listen(3000);
```

### **Why it's useful:**

* It helps you define reusable functions for handling requests in a clean and organized way.



#### What is the body parser used for ?
**Body-parser** is a middleware in Express.js used to **parse incoming request bodies**. It helps to extract data from the body of HTTP requests (like POST requests) and make it accessible in your routes.

### **What it does:**

* It parses data sent in the body of requests (e.g., form data, JSON).
* Makes it available in `req.body` for easy access.

### **Example**:

```js
const express = require('express');
const bodyParser = require('body-parser');
const app = express();

// Use body-parser to parse JSON data
app.use(bodyParser.json());

app.post('/data', (req, res) => {
  console.log(req.body);  // Access the parsed data
  res.send('Data received');
});

app.listen(3000);
```

### **Why it's useful:**

* Makes it easy to work with JSON or form data sent in HTTP requests.

**Note:** In newer versions of Express (4.16+), `body-parser` is no longer needed as Express has built-in body parsing capabilities with `express.json()` and `express.urlencoded()`.




#### what is __dirname in path module ?s
`__dirname` is a **Node.js variable** that provides the **absolute path** to the **directory** where the currently executing script is located.

### **What it does:**

* It helps you get the **full directory path** of the current script file.
* Often used to build file paths relative to the current file.

### **Example**:

```js
console.log(__dirname);  
// Output: '/path/to/current/directory'
```

### **Why it's useful:**

* It ensures that you can reference files correctly, no matter where the script is executed from.

### Common use with **path module**:

```js
const path = require('path');
console.log(path.join(__dirname, 'folder', 'file.txt'));
// Output: '/path/to/current/directory/folder/file.txt'
```




#### What is dynamic routing ?
**Dynamic routing** refers to the ability to handle routes in a web application where the **route parameters** (like user IDs, item names, etc.) can change based on the request.

### **What it does:**

* Allows you to define routes that can respond to **variable parts** in the URL.
* It makes your routes **dynamic** by allowing parameters to be passed in the URL.

### **Example in Express**:

```js
const express = require('express');
const app = express();

// Dynamic route with a parameter 'id'
app.get('/user/:id', (req, res) => {
  const userId = req.params.id;  // Access the dynamic 'id' parameter
  res.send(`User ID is ${userId}`);
});

app.listen(3000);
```

### **Why it's useful:**

* Makes it possible to create routes that respond to different inputs (e.g., user profiles, product pages).

For example, `/user/1` and `/user/2` would be handled by the same route, but the response would differ based on the value of `:id`.




#### What is query and param ?
In the context of web development, especially in Express.js, **query** and **params** are two ways to pass information through the URL.

### **Query:**

* **Query parameters** are passed in the **URL after the `?`** and are usually in the form of key-value pairs.
* They are often used for optional data or filtering.

### **Example:**

* URL: `https://example.com/search?query=apple&sort=price`

  * **Query parameters**: `query=apple`, `sort=price`
  * Access them in Express:

    ```js
    app.get('/search', (req, res) => {
      const query = req.query.query;  // 'apple'
      const sort = req.query.sort;    // 'price'
      res.send(`Search for ${query}, sorted by ${sort}`);
    });
    ```

### **Params (Route Parameters):**

* **Route parameters** are passed as part of the **URL path**, defined by a `:` in the route.
* They are used for **required** data, like an ID or slug.

### **Example:**

* URL: `https://example.com/user/123`

  * **Route parameter**: `123` (user ID)
  * Access them in Express:

    ```js
    app.get('/user/:id', (req, res) => {
      const userId = req.params.id;  // '123'
      res.send(`User ID is ${userId}`);
    });
    ```

### **Summary:**

* **Query**: Optional data passed after `?`, accessed via `req.query`.
* **Params**: Required data passed in the URL path, accessed via `req.params`.



#### What is OPTIONs call  and when does it happen and why does it happen
The **OPTIONS** HTTP method is used to **request information about the communication options available** for a particular resource or server. It is commonly used in **CORS (Cross-Origin Resource Sharing)** requests.

### **When it happens:**

* It is sent automatically by the browser as a **pre-flight request** before making a cross-origin request (when different domains are involved).
* Happens when the browser needs to check if the server **allows** the actual request (like `POST`, `PUT`, etc.) from a different domain.

### **Why it happens:**

* It helps determine if the actual request is safe to send based on the server's response (like allowed HTTP methods or headers).
* It’s a security measure to **avoid making unsafe requests** across origins.

### **Example scenario:**

If you're making a **cross-origin** `POST` request from `http://example.com` to `http://api.example.com`, the browser first sends an **OPTIONS** request to check if the `POST` method is allowed. If the server responds correctly, the browser proceeds with the actual `POST` request.

### **OPTIONS Request Example**:

```bash
OPTIONS /resource HTTP/1.1
Host: api.example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Content-Type
```

### **Why it's useful:**

* It ensures safe cross-origin requests.
* Helps servers communicate which methods and headers are allowed.





#### What is URL
A **URL** (Uniform Resource Locator) is the **address** used to access resources on the internet, like websites, images, or files.

### **What it consists of:**

1. **Protocol**: The method used to access the resource (e.g., `http://`, `https://`).
2. **Domain name**: The website's address (e.g., `example.com`).
3. **Path**: The specific resource or page on the website (e.g., `/about`).
4. **Query parameters** (optional): Additional information, often in key-value pairs (e.g., `?search=apple`).

### **Example URL:**

```
https://www.example.com/products?id=123&category=shoes
```

* **Protocol**: `https://`
* **Domain**: `www.example.com`
* **Path**: `/products`
* **Query parameters**: `?id=123&category=shoes`

### **Why it's useful:**

* It provides a way to locate and access resources across the web.




#### What is header ?
A **header** in HTTP is **metadata** sent along with a request or response, providing additional information about the request or response itself.

### **Types of Headers:**

1. **Request Headers**: Sent from the client (browser or app) to the server to provide context or details about the request.

   * Example: `Content-Type`, `Authorization`, `User-Agent`.

2. **Response Headers**: Sent from the server back to the client, containing metadata about the response.

   * Example: `Content-Type`, `Set-Cookie`, `Cache-Control`.

### **Example of Request Header:**

```http
GET /home HTTP/1.1
Host: example.com
Authorization: Bearer token123
```

### **Why headers are useful:**

* Headers help in **defining** the behavior of the request or response.
* They are used for **authentication**, **content type**, **caching**, and more.



#### What are routes

**Routes** in web development are the **paths or endpoints** that define how an application responds to different **HTTP requests** (like GET, POST, etc.) to specific URLs.

### **What routes do:**

* A route maps a URL pattern to a specific function or **handler** in your app.
* When a user visits a URL, the server looks for the matching route to handle that request.

### **Example in Express.js:**

```js
const express = require('express');
const app = express();

// Define a route for GET request to "/"
app.get('/', (req, res) => {
  res.send('Hello, World!');
});

// Define a route for GET request to "/about"
app.get('/about', (req, res) => {
  res.send('About Us');
});

app.listen(3000);
```

### **Why routes are useful:**

* They organize how different parts of your web application should respond to requests.
* They help define the **structure** of your web app’s URL system.

Let me know if you'd like to see more examples or details on routing!
