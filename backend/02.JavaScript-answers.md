#### What is difference between let, const and var?
    - let and const were introduced in ES6, but var was used from the beginning
    - let and const are function scoped and var is block scoped
    - let and var can be declared without value but same is not possible with const
    - value of the let and var variables can be changed but it is not possible with const
    - variable with the same name in same scope can be declared using var but it is not possible with let and const
    - Hoisting happens differently with let and const than it happens with var
---
#### Explain the event loop in js

### Steps:
1. **Call Stack**: JavaScript starts by executing code synchronously, which goes into the call stack.
2. **Web APIs (Browser) / Node.js APIs**: Asynchronous operations (like `setTimeout`, file I/O) are handled outside the call stack by Web APIs (in browsers) or Node.js APIs.
3. **Callback Queue**: When these async operations are done, their callbacks are added to the callback queue.
4. **Event Loop**: The event loop constantly checks if the call stack is empty. When it’s empty, it takes the first callback from the callback queue and pushes it onto the call stack to execute.
5. **Repeat**: The event loop keeps running, processing tasks as long as there are callbacks waiting in the queue.


### Key Points:
- The event loop processes asynchronous tasks only after the call stack is empty.
- It’s what allows JavaScript to perform non-blocking operations in a single thread.


---
#### What is the difference between pre and post increment?

#### What is the difference between temp++ and ++temp


In JavaScript:

- **Pre-increment (`++i`)**: The value of `i` is incremented **before** it's used in the expression.

  Example:
  ```javascript
  let i = 5;
  let j = ++i;  // i becomes 6, then j is assigned 6
  ```

- **Post-increment (`i++`)**: The value of `i` is used **before** it's incremented.

  Example:
  ```javascript
  let i = 5;
  let j = i++;  // j gets 5, then i becomes 6
  ```

### Summary:
- **Pre-increment**: Increments first, then uses the value.
- **Post-increment**: Uses the value first, then increments.
---

#### how can you print a first and b later with. You are not allowed to use any extra setTimeouts?

```javascript
setTimeout(()=>{
console.log("a");
},2000)
console.log("b") ;
```


---

#### What is the typeOf an array in javascript?
    typeOf an array in javascript is Object
---

#### how can you check if a variable is an array?
    We can use Array.isArray() method
---

#### What is the Difference between setTimeout, setInterval setImmediate and process.nextTick?
**`setTimeout`**:  
It takes 2 arguments, one is function to be executed and second is timer in millisecond in which the function should be executed.  
  
It does not guarantee that it will take exactly given time but it gives guarantee that it will take minimum given time.  
  
Once the code sees setTimeout, it pushes that code out of the call stack to timer API, once that time is complete setTimeout will be passed to call back queue, so after the completion of current event loop, call back queue is checked and from there setTimeout is executed.  
  
We can use `clearTimeout(id)` method to clear the setTimeout.


**`setInterval`**:  
It takes 2 arguments, one is function to be executed and second is interval in milliseconds at which the function should be repeatedly executed.  
  
It does not guarantee exact interval execution but ensures the function is called at least after the specified interval repeatedly.  
  
Once the code sees setInterval, it pushes that code out of the call stack to timer API, and after every interval, the function is added to the call back queue to be executed after the current event loop cycle.  
  
We can use `clearInterval(id)` method to clear the setInterval.


**`setImmediate`**:  
It takes one argument — the function to be executed immediately after the current event loop phase.  
  
It does not depend on any timer and is executed after the current poll phase completes.  
  
Once the code sees setImmediate, it pushes the function to the check phase of the event loop, and it is executed after I/O events are processed.  
  
We can use `clearImmediate(id)` method to clear the setImmediate.

**`process.nextTick`**:
It takes a callback function and schedules it to run immediately after the current operation completes, before the event loop continues.

It has higher priority than any other asynchronous task like setTimeout, setImmediate, or I/O callbacks.

It belongs to the microtask queue and executes before moving to the next event loop phase.

process.nextTick is available only in Node.js, and not in browser environments.

It should be used carefully, as heavy usage can block the event loop and delay I/O or timers.


---



#### What is the Difference between arr.foreach,  array.map and array.filter?

**`array.forEach`**:  
It takes a callback function and executes that function once for each element in the array.  
  
It does **not return a new array**, and it is generally used for performing side effects like logging or modifying external variables.  
  
It cannot be chained and `return` inside it does not affect the outer function.  


**`array.map`**:  
It takes a callback function and returns a **new array** with the results of calling the callback on every element.  
  
It does **not modify the original array**, and is used when you want to **transform** each element of the array.  
  
The length of the new array is always the same as the original array and new array is the result of function applied to the each element.


**`array.filter`**:  
It takes a callback function and returns a **new array** containing only the elements for which the callback function returns `true`.  
  
It is used for **filtering elements based on a condition**, and does not modify the original array.  
  
The length of the returned array may be less than or equal to the original array.

---



#### What is the temporal dead zone?

The **temporal dead zone (TDZ)** is the time between entering a scope and when a `let` or `const` variable is declared and initialized. Accessing the variable during this time results in a **ReferenceError**.

---


#### What is the Difference between null and undefined.

**`undefined`:**  
- `undefined` is a placeholder for variables until real values are assigned.  
- It means a variable has been declared but not assigned a value.  
- The type of `undefined` is **"undefined"**.

**`null`:**  
- `null` is an assigned value that represents no value or no object.  
- It explicitly indicates the absence of any value.  
- The type of `null` is **"object"** (this is a known quirk in JavaScript).
---


#### What is the Difference between undeclared and undefined.
Before any JavaScript code is executed, there are **two phases**:

1. **Memory Allocation Phase**  
   - In this phase, variables and functions are stored in memory.  
   - Variables declared with `var` are assigned a temporary value of `undefined`.  
   - `let` and `const` are also allocated in memory but are not initialized (they stay in the **Temporal Dead Zone**).

2. **Code Execution Phase**  
   - In this phase, the actual code runs and variables are assigned their real values.


**`undefined`**:  
- The variable exists in memory and has been declared, but no value has been assigned yet.  
- JavaScript automatically sets it to `undefined`.

**`undeclared`**:  
- The variable does **not** exist in memory.  
- It was **never declared** in the code, and accessing it will throw a **ReferenceError**.
---


#### What is the Difference between ‘==’ and ‘===’ .

- **`==` (Abstract Equality Operator)**  
  - Compares two values for equality **after converting** them to a common type (type coercion).  
  - Returns `true` if the values are equal **after** type conversion.  
  - Example: `5 == '5'` → `true`

- **`===` (Strict Equality Operator)**  
  - Compares two values for equality **without converting** their types.  
  - Returns `true` only if both the **value and type** are the same.  
  - Example: `5 === '5'` → `false`
---

#### What is Rest and spread operator


**Rest Operator (`...`)**  
- Collects the remaining elements into an array.  
- Used in **destructuring**.  
- Must be the **last** element.

Example:  
```javascript
const [a, ...b] = [1, 2, 3, 4];
console.log(a); // 1
console.log(b); // [2, 3, 4]
```

---

**Spread Operator (`...`)**  
- Spreads elements into a new array or object.  
- Used in **expansion**.

Example:  
```javascript
const arr1 = [1, 2];
const arr2 = [...arr1, 3, 4];
console.log(arr2); // [1, 2, 3, 4]
```
---


#### const fun = () => arguments.length;
    console.log(fun(1,2));
    What is the output?

**`arguments` object:**  
- Available in **regular functions** — holds all passed arguments.  
- **Not available** in **arrow functions**.

Arrow functions don’t have their own `arguments`.  
They can only access `arguments` from the nearest **non-arrow** parent function.

Example (will throw error):  
```javascript
const func = () => {
  console.log(arguments); // Error: arguments is not defined
};
func(1, 2, 3);
```
---


#### When do we use async await ?

**`async/await` in JavaScript:**  
- A simpler way to work with **promises**.  
- Makes **asynchronous code** look and behave like regular (synchronous) code.  
- `await` pauses the function until the promise is **resolved**.  
- Helps make code **cleaner and easier** to read than using `.then()` or callbacks.

Example:  
```javascript
async function getData() {
  const result = await fetch('url');
  console.log(result);
}
```
---

#### What is callback? What is Callback hell? Can you give an example of callback hell?

callback is a function which is passed as argument to another function for later execution, callback hell is a problem when callback function becomes nested and instead of code growing vertically it starts to grow horizontally which makes code hard to read and manage, we also call it as pyramid of doom. 

Example for callback hell in js

```javascript
function a (callback){
		setTimeout(()=>{
			console.log('a');
			callback();
		},1000)
	}


	function b (callback){
		setTimeout(()=>{
			console.log('b');
			callback();
		},1000)
	}

	function c (){
		setTimeout(()=>{
			console.log('c');
		},1000)
	}

	a(()=>{
		b(()=>{
			c() // This is a callback hell
		})
	})

```

---




#### How do promises solve the issue of callback hell?
- promises gives guarantee that it is going to execute either resolve or reject at least once
- Promise makes error handling easy by .catch block
- Promise syntax makes code easier to maintain
- Promise solve problem of callback hell by giving a proper way to call callback function with .then block

#### Why do we use promises over callbacks and why use await and async?
    same answer

---

#### What are promises? 3 states of promises.
- Promise is an object which represents eventual completion of an async operation. The 3 states of promise are 
1. Pending 
2. Resolved 
3. Rejected
---



#### What is difference between promise and call back.
Promise is an object which represents eventual completion of an async operation

Callback is a function which is passed as argument to other function for later execution.

#### What were the 10 new features that were introduced in ES6? Explain each one of them in detail?

- 1. Variable declaration using let and const
- 2. Map and Set
- 3. Arrow function
- 4. for of and for in loops
- 5. class
- 6. Template literals
- 7. Spread and rest operators
- 8. Object  and Array destructuring
- 9. Promises
- 10. Modules
---


#### when to use for of and when to use for in loops in js

- **Use `for...of`** when you want to iterate over the **values** of iterable objects like arrays.
- **Use `for...in`** when you want to iterate over the **keys** (property names) of objects.
---


#### What is Call, Apply, Bind. When to use what ? Can you give an example?
In JavaScript, call(), apply(), and bind() are methods that can be used to change the context of this keyword present inside the invoking function. They are used to set the value of this independently of how the function is called, and to pass arguments to a function in a specific way. 

	When to Use Call(), Apply(), and Bind() Methods

	We Use call() when we want to call a function with a specific value of this
	We Use apply() when we want to call a function with a specific value of this, and pass arguments as an array
	We Use bind() when we want to create a new function with a specific value of this, which can be called later.

	Example Usage of Call(), Apply(), and Bind()

```js
	const person = {
	 name: 'John',
	 age: 30,
	};

	function sayHello(greeting) {
	 console.log(`${greeting}, my name is ${this.name} and I am ${this.age} years old.`);
	}

	// Using call()
	sayHello.call(person, 'Hello');

	// Using apply()
	sayHello.apply(person, ['Hello']);

	// Using bind()
	const sayHelloToPerson = sayHello.bind(person);
	sayHelloToPerson('Hello');
```
---








#### What are different ways to store data in browser? Explain each one of them and when should we use what?
a.Local Storage
b.Session Storage
c.Cookies

Cookies:
Cookies are small text files that are stored in the user browser by websites. Cookies have several limitations, including a small size limit of 4KB, and the fact that they are sent to the server with every HTTP request.

Local Storage
Local storage is a key-value storage mechanism that allows websites to store data locally in the user browser. It has a much larger storage capacity than cookies (up to 5-10 MB), and the data stored in local storage is not sent to the server with every HTTP request.

Session Storage
Session storage is similar to local storage in that it is also a key-value storage mechanism. However, the data stored in session storage is only available for the duration of the current browser session. When the user closes the browser or navigates away from the website, the data is deleted.

When we want to store small data such as user preference or token which need to be sent to server on every http request then we need to store data in cookies
When we want to store larger data such as user configuration of website, which need not to be sent to browser on every request then we have to use local storage.
When we want to store temporary data in user browser for only in our tab then we have to use session storage.




how to use cookies and session storage in js

### Cookies:

**Setting a Cookie:**
```javascript
document.cookie = "key=value; expires=Thu, 01 Jan 2022 00:00:00 UTC; path=/";
```

**Getting a Cookie:**

    const cookies = document.cookie.split('; ');

```

### Session Storage:

**Setting a Session Storage Item:**
```javascript
sessionStorage.setItem('key', 'value');
```

**Getting a Session Storage Item:**
```javascript
const value = sessionStorage.getItem('key');
console.log(value);
```

**Removing a Session Storage Item:**
```javascript
sessionStorage.removeItem('key');
```

### Note:
- Cookies have more features, such as an expiration date, path, domain, and secure flag.
- Session storage is generally simpler to use and is limited to the duration of a page session.
- Be cautious with the data you store on the client side, especially in cookies, as it can be manipulated by the user.

---


#### What are generator function in javascript ? How are they different from normal function?

	A generator function in JavaScript is a special type of function that can be paused and resumed during its execution. When a generator function is called, it returns a generator object that can be used to control the execution of the function.

	Generator functions have a similar syntax to regular functions . The only difference is that the generator function is denoted by an asterisk (*) after the function keyword .

	They are different from normal function in several ways
		1.Generator functions use the yield keyword to pause and resume execution, while normal functions use the return keyword to terminate execution.
		2.Generator functions can be paused and resumed during execution, while normal functions run to completion in a single execution.
		3.Generator functions return a generator object, which can be used to control the execution of the function, while normal functions return a value or undefined.

```js
function* myGenerator(){
    yield 1;
    yield 2;
    return 10;
}

const gen = myGenerator()
console.log(gen.next());
console.log(gen.next());
console.log(gen.next());
console.log(gen.next());
```
---

#### what is the use of generator function 
A **generator function** in JavaScript is used to **pause** and **resume** the execution of a function, allowing you to produce values one at a time, on demand. It's especially useful for handling large datasets, asynchronous workflows, or iterating over sequences lazily (without generating all values upfront).

### Key Uses:

1. **Lazy Evaluation**:
   - **Generates values on demand** without needing to compute or store the entire sequence upfront. This is useful for working with large datasets or infinite sequences.
   
   Example:
   ```javascript
   function* generateNumbers() {
     let i = 1;
     while (true) {
       yield i++;  // generates numbers 1, 2, 3, ...
     }
   }

   const gen = generateNumbers();
   console.log(gen.next().value); // 1
   console.log(gen.next().value); // 2
   console.log(gen.next().value); // 3
   ```

2. **Asynchronous Programming**:
   - **Simplifies working with asynchronous code** by pausing execution at certain points (`yield`) and resuming once a promise is resolved. This can make asynchronous code more readable and easier to manage, often used in conjunction with `async`/`await`.
   
   Example (with `yield` and promises):
   ```javascript
   function* fetchData() {
     const data = yield fetch('https://api.example.com/data');  // pause here until fetch completes
     console.log(data);  // will resume when data is available
   }

   const gen = fetchData();
   gen.next();  // initiate the generator
   ```

3. **Custom Iterators**:
   - **Custom iteration logic**: Generators can be used to define custom iteration behavior for objects, useful for when you want to iterate through a collection with specific rules.
   
   Example:
   ```javascript
   function* customRange(start, end) {
     for (let i = start; i <= end; i++) {
       yield i;
     }
   }

   const range = customRange(1, 3);
   console.log(range.next().value);  // 1
   console.log(range.next().value);  // 2
   console.log(range.next().value);  // 3
   ```

### Summary:
- **`yield`**: Pauses the function and returns a value.
- **`next()`**: Resumes execution and gets the next value.
- **Lazy iteration**: Generates values only when needed, saving memory and computation.

Generator functions are perfect for scenarios where you need control over when and how values are produced, such as iterating over large datasets or handling asynchronous operations.


#### What is the use of arr.reduce? Explain with an example.
The **`reduce()`** method in JavaScript is used to **accumulate** or **reduce** an array to a single value by applying a function to each element of the array.

### Syntax:
```javascript
arr.reduce((accumulator, currentValue, index, array) => {
  // return the updated accumulator
}, initialValue);
```

- **`accumulator`**: The accumulated value returned by the last call of the callback.
- **`currentValue`**: The current element being processed.
- **`initialValue`**: The value to start the accumulation (optional).

### Example: Sum of All Numbers in an Array
```javascript
const numbers = [1, 2, 3, 4, 5];

const sum = numbers.reduce((accumulator, currentValue) => {
  return accumulator + currentValue;
}, 0);

console.log(sum);  // Output: 15
```

### Explanation:
- **Initial Value**: `0` (starting point for the accumulation).
- **Accumulator**: Keeps the running total.
- **Current Value**: The current number being added to the accumulator.

`reduce()` iterates through the array and keeps adding each number to the accumulator, resulting in the sum of all the numbers.

### Summary:
`reduce()` is used to **accumulate** values (like sum, product, etc.) in an array into a single value.

#### what will the output (true or false) of the following be?Explain why?
    console.log(null === undefined)
    console.log(null == undefined)

#### What is event bubbling and event capturing (Event Propagation)? what is the difference between them? Can you give a code  example to explain how you can use event bubbling ?
  Event bubbling means innermost elements event is handled first and then the   outer elements event is handled.
	In Event capturing outermost elements event handled first and then the inner.

	addEventListener function takes 3 arguments one is event on which the function should be invoked and second is the function to be invoked and third is by default is false meaning event bubbling Propagation is handled, we can change it to true to make it event capture Propagation.


#### How to find the length of an object.
  We can use Object.keys() method which returns an array containing all the keys of the object, then we can use .length method on that array to find the length of the object.

#### Explain the different ways of creating object in javascript? Explain all the 3 ways.


	A.Object Literal Notation
	  The most common way to create an object in JavaScript is by using object literal notation. In this approach, we define the object properties and methods directly within curly braces {}

	  // Creating an object using object literal notation
	  const person = {
	   name: "Amar",
	   age: 30,
	   greet: function() {
	    console.log(`Hello, my name is ${this.firstName} and I'm ${this.age} years old.`);
	   }
	  };


	B.Constructor Functions
	  Constructor functions are used to create multiple objects with the same structure. They serve as a blueprint for creating objects, and we use the new keyword to instantiate new instances of the object.
	  // Constructor function
	  function Person(name, age) {
	   this.name = name;
	   this.age = age;
	   this.greet = function() {
	    console.log(`Hello, my name is ${this.firstName} and I'm ${this.age} years old.`);
	   }
	  }

	  // Creating objects using the constructor function
	  const person1 = new Person("Amar", 30);
	  const person2 = new Person("Amith", 25);

	C.ES6 Classes:
	  ES6 introduced a more easy way to create objects using classes. Classes makes object-oriented programming concepts more familiar to developers coming from other languages.

	  // ES6 Class
	  class Person {
	   constructor(name, age) {
	    this.name= name;
	    this.age = age;
	   }

	   greet() {
	    console.log(`Hello, my name is ${this.firstName} and I'm ${this.age} years old.`);
	   }
	  }

	  // Creating objects using ES6 classes
	  const person1 = new Person("Amar", 30);
	  const person2 = new Person("Amith", 25);



#### What are Object Prototype Methods
  In JavaScript, every object is linked to a prototype object from which it can inherit properties and methods. Object prototype methods are functions that are defined on the prototype object and are available for use by all instances of that object type.

	Some commonly used prototype methods are as follows:
		Object.keys(obj): Returns objects all keys as an array
		Object.values(obj): Returns objects all values as an array
		Object.entries(obj): Returns an array of arrays, where each inner array contains a key-value pair from the object
		Object.freeze(obj): Freezes an object, preventing any further changes to its properties
		Object.seal(obj): Seals an object, preventing the addition or deletion of properties, though the values of existing properties can still be changed
		Object.is(value1, value2): Compares two values to determine if they are the same value (similar to strict equality ===)



#### How to iterate inside and object and print all the values inside it without the keys? Give a code example?
  we can use Object.values method to get all the values as an array and later we can run a loop on the array to print all the values

#### What is object chaining in javascript? Can you create functions to explain object chaining better?

  Object chaining, also known as method chaining, is a technique in JavaScript where multiple methods are called on an object one after another, using dot notation. Each method call returns the modified object, allowing us to chain another method call immediately

    let calculator = {
    value: 0,

    add(num) {
      this.value += num;
      return this;
    },

    subtract(num) {
      this.value -= num;
      return this;
    },

    getValue() {
      return this.value;
    }
    };

    const result = calculator.add(10).subtract(5).add(7).getValue();// here we making object chaining by calling one method after another
    console.log(result); // it prints 12

#### What is the main difference between fat arrow function and normal function?

	There are 3 main difference between normal function and fat arrow functions

	A. Syntax:
	Normal functions are defined using function keyword and optional name.
	arrow funtions are defined using Fat arrow symbol

	B.Arguments:
	Normal functions have array like object called Arguments, which has all the arguments passed to this functions as elements.
	Arrow functions dont have their own arguments object, but they can get arguments object from nearby functions.

	C.this keyword:
	Normal functions have their own this context, which can vary based on how the function is called. The value of this is determined by the functions invocation.
	Arrow functions do not have their own this context. Instead, they inherit the this value from the enclosing lexical scope



#### Can you give an example to explain how "this" works differently with fat arrow function and normal function and Explain “this” keyword ?

































#### What are the advantages of Axios vs other competitors( like fetch, http, got etc)? Why is axios so widely used?

	Axios is a popular JavaScript library used for making HTTP requests in browsers and Node.js

		Promise-Based API: Axios uses promises, which allows for cleaner and more easy asynchronous code. It simplifies error handling and chaining of multiple requests.

		Browser and Node.js Support: Axios is designed to work both in web browsers and Node.js environments.

		Request Cancellation: Axios provides built-in support for request cancellation, which is helpful in scenarios where we want to cancel ongoing requests when they are no longer needed, preventing unnecessary network traffic and freeing up resources.

		Client and Server-Side Support: Axios can be used on both the client and server sides.

		Interceptors: Axios allows you to define request and response interceptors, which can modify requests or responses globally. This is useful for scenarios such as adding headers, handling errors, and modifying data.

		Community and Documentation: Axios has a strong community and well-maintained documentation. This makes it easy for developers to find help and resources when working with the library.



#### What is the output of this console.log(0.1 + 0.2). Why is it not 0.3?

#### What will be the output of this console.log((0.2 + 0.3) === 0.5)
	Output of the given code is true, it adds 0.2 to 0.3 and answer will be 0.5 which is true.

#### What is NaN property in JavaScript?


	In JavaScript, NaN stands for Not-a-Number, It is a special value that represents the result of a mathematical operation that cannot be expressed as a valid number. When a mathematical operation or function is performed that doesn't produce a meaningful number result, JavaScript returns NaN to indicate that the result is not a valid number.

	ex:
	console.log('string' / 2); // output is NaN because we cannot divide number with string


#### Explain pass by value and pass by reference? Give code example of how you would pass by reference in javascript?

	Pass by Value:
	In pass by value, a copy of the actual value of a variable is passed to the function. Any modifications made to the parameter inside the function do not affect the original variable outside the function.



	function modifyValue(x) {
	  x = x * 2;
	}



	let num = 5;
	modifyValue(num);
	console.log(num); // Output is 5,

	In this example, the modifyValue function takes a copy of the value stored in the num variable. Even though x is modified inside the function, it doesnt affect the original num variable.



	Pass by Reference:

	In pass by reference, a reference (memory address) to the variable is passed to the function. This means any changes made to the parameter inside the function also affect the original variable outside the function.

	function modifyArray(arr) {
	  arr.push(4);
	}



	let myArray = [1, 2, 3];
	modifyArray(myArray);
	console.log(myArray); // Output is [1, 2, 3, 4]

	In this example, the modifyArray function takes a reference to the myArray variable. When we push a value onto the arr parameter inside the function, it also affects the original myArray variable.



#### What is memoization in javascript? Can you give a code example implementing the same?

	Memoization is a programming technique used to optimize the execution of functions by caching the results of expensive function calls and returning the cached result when the same inputs occur again. Its a way to avoid expensive computations and improve the overall performance of our code.


	In JavaScript, we can implement memoization using various approaches, such as using objects, arrays, or even external libraries. Here is a simple example of memoization using an object to cache the results of a Prime number calculation:



	let memo = {};

	function isPrime(n, memo) {

	 console.log(memo);

	 if (n in memo) {
	  return memo[n]; // Return cached result if available
	 }



	 if (n <= 1) {
	  return false;
	 }



	 for (let i = 2; i < n; i++) {
	  if (n % i === 0) {
	   memo[n] = false;
	   return false;
	  }
	 }

	 memo[n] = true;
	 console.log(memo);
	 return true;
	}



	console.log(isPrime(3,memo)); // Output is true
	console.log(isPrime(10,memo)); // Output is false
	console.log(isPrime(3,memo)); // Output is true (cached)



#### What is the data type of variables in JavaScript?

	In JavaScript, variables are dynamically typed, which means that their data type can change during runtime based on the value assigned to them. JavaScript has several primitive data types:

	Undefined: This represents a variable that has been declared but hasnot been assigned a value yet.
	Null: Represents the intentional absence of any value.
	Boolean: Represents a true or false value.
	Number: Represents both integer and floating-point numbers.
	String: Represents a sequence of characters, enclosed in single or double quotes.
	Object: Represents complex data structures and includes arrays, functions, and custom objects.


#### What are escape characters? Why are they used? Give code example.
	Escape characters in JavaScript are special characters that are used to represent characters that cannot be typed directly into a string or have a special meaning in JavaScript syntax. These characters are preceded by a backslash (\) to indicate that they should be treated as literal characters rather than having their usual interpretation. Escape characters are used to handle various situations, such as including special characters in strings, creating multi-line strings, and representing characters that are not easily typed on a keyboard.

	Here are some common escape characters in JavaScript:

	 '\"': Double quote (`"`)
	 '\'': Single quote (`'`)
	 `\\`: Backslash (`\`)
	 `\n`: Newline (line break)
	 `\t`: Tab
	 `\r`: Carriage return
	 `\b`: Backspace
	 `\f`: Form feed
	 `\uffff`: Unicode character with the specified hexadecimal code point (ffff represents the hexadecimal value)



#### What is break and continue statements? How are they different?

	In JavaScript, break and continue are control flow statements used within loops (such as for, while, and do...while) to alter the normal flow of execution.

	Break Statement:
	The break statement is used to immediately terminate the execution of a loop, be it a for, while, or do...while loop. When the break statement is encountered inside a loop, the loop is exited, and the program continues executing the next statement after the loop.


	Continue Statement:
	The continue statement is used to skip the rest of the current iteration of a loop and immediately move to the next iteration. It effectively skips the remaining code within the loop body for the current iteration and jumps to the next iteration.

	Key Differences:
		Behavior:
		break terminates the entire loop immediately when encountered.
		continue skips the current iterations remaining code and moves to the next iteration.


		Usage:
		break is typically used when we want to exit a loop prematurely based on a certain condition.
		continue is used when we want to skip the remaining code within a loops body for a specific iteration based on a condition.


#### What's the difference between event.preventDefault() and event.stopPropagation() methods in JavaScript?


	In JavaScript, both event.preventDefault() and event.stopPropagation() are methods used to manipulate event behavior, but they serve different purposes in the event propagation process.

	event.preventDefault():

	This method is used to prevent the default behavior of an event from occurring. In other words, when an event is triggered (e.g., a form submission, a link click, a keypress), browsers often have default actions associated with that event. Calling event.preventDefault() stops the browser from executing its default action.

	event.stopPropagation():

	This method is used to stop the further propagation of an event through the DOM hierarchy. When an event occurs on an element, it can trigger the same event on its parent elements, bubbling up the DOM tree. Calling event.stopPropagation() prevents this bubbling phase from continuing.


	In short, event.preventDefault() is used to prevent the default behavior of an event (e.g., form submission, link navigation), while event.stopPropagation() is used to prevent an event from triggering event listeners on parent elements (event bubbling).




#### What is function definition ?
  Function definition is also known as function declaration and function statement. In function declaration we define function with function keyword and we don't assign it to any variable, we can do hoisting in function declaration. 

#### Explain Hoisting 
  Hoisting is a behavior in js in which we can access variable and functions even before initializing them with value without getting any error.It happens because even before code start executing a single line memory is allocated to each variable and functions

#### What are higher order function ? Explain with code example.
  A function which takes one or more functions as arguments or returns a function as output is a higher order function.

#### What are first class function ?
	First class functions are functions that can be treated like any other value , like it can be assigned to variable , passed as argument to another function , returned as output from other function.


#### What are anonymous functions in js? Give an example? what is its use ?
	A function without a name is anonymous function.
	(()=>{
	 console.log('Im anonymous');
	})()


#### What are closures? Explain with an example?
	closures are functions that have access to variable in their outer lexical scope, even after the outer function is returned.


#### What is function currying? Can you create a curried function and explain?***, what is the use of curring ?
### What is Function Currying?

**Function currying** is a technique in JavaScript (and other functional programming languages) where a function is transformed into a sequence of functions, each taking a single argument. Instead of passing all arguments at once, currying allows you to pass one argument at a time, and each function returns another function that expects the next argument, until all arguments are provided.

In other words, currying takes a function that would normally accept multiple arguments and transforms it into a chain of functions that each take one argument.

### Example of Currying

Here’s an example of how a simple curried function works:

```javascript
// A simple curried function to add three numbers
function add(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    }
  }
}

// Usage:
const result = add(1)(2)(3);  // 6
console.log(result);
```

### Explanation:
1. **First Call**: `add(1)` returns a function that expects the second argument `b`.
2. **Second Call**: `add(1)(2)` returns a function that expects the third argument `c`.
3. **Third Call**: `add(1)(2)(3)` finally returns the result of `a + b + c`, which in this case is `1 + 2 + 3 = 6`.

This process is called **currying** because you are "breaking down" the function into a series of smaller functions that each handle one argument at a time.

---

### Use of Currying in JavaScript

#### 1. **Partial Application**
Currying allows you to create functions with pre-set arguments. This is known as **partial application**, where you can preset some arguments in advance and call the function later with the remaining ones.

Example:

```javascript
function multiply(a, b) {
  return a * b;
}

// Curried version of multiply
function curriedMultiply(a) {
  return function(b) {
    return a * b;
  }
}

const double = curriedMultiply(2);  // Partial application: set 'a' to 2
console.log(double(5));  // 10 (Equivalent to multiply(2, 5))
```

In this case, `double` is a partially applied version of `multiply` where `a` is fixed to `2`. So, `double(5)` is equivalent to `multiply(2, 5)`.

#### 2. **Improved Reusability and Composability**
With currying, you can reuse functions by fixing one or more arguments in advance, and then composing them in various ways to build more complex behaviors.

Example:

```javascript
function calculate(a) {
  return function(b) {
    return a + b;
  }
}

const add5 = calculate(5);  // Fixing 'a' to 5
const add10 = calculate(10);  // Fixing 'a' to 10

console.log(add5(10));  // 15
console.log(add10(5));  // 15
```

In this case, you’ve created reusable functions `add5` and `add10` that can be used in different contexts without rewriting the logic.

#### 3. **Cleaner Code and Function Composition**
Currying leads to cleaner and more modular code. It enables function composition, where you can combine multiple smaller functions into a larger one in a flexible manner.

Example with function composition:

```javascript
function add(a) {
  return a + 2;
}

function multiply(a) {
  return a * 3;
}

function subtract(a) {
  return a - 5;
}

// Compose functions using currying
const composedFunction = subtract(multiply(add(3))); 
console.log(composedFunction); // Result: (3 + 2) * 3 - 5 = 6
```

---

### Benefits of Currying:

1. **Partial Application**: Currying makes it easier to create partially applied functions that can be reused with different arguments.
2. **Cleaner Code**: Currying promotes small, modular, and reusable functions, leading to cleaner and more maintainable code.
3. **Function Composition**: You can easily combine functions to create more complex behavior using the result of one function as the input to another.
4. **Flexibility**: Currying enables flexible and dynamic function calls, especially in scenarios where some arguments are known in advance.

---

### Summary:

- **Function Currying**: A technique where a function is broken down into a series of functions that each take one argument, returning a new function that expects the next argument, and so on.
- **Use Cases**:
  - **Partial application**: Fixing some arguments in advance.
  - **Cleaner, more modular code**: Creating reusable small functions.
  - **Function composition**: Combining smaller functions into more complex ones.




#### What is an IIFE (Immediately Invoked function expression)? Can you give an example? What is its use ?

	When a function is executed immediately after its declaration is known as immediately invoked function expression.

	ex:
	(function immediatelyInvoke(){
		console.log('immediately invoked');

	})()

#### What is lexical scope ?
	Lexical scope refers to the visibility and accessibility of variable in a program based on their location within nested blocks of code, variable declared in an outer scope are accessible to inner scope , but reverse is not possible.

#### Is js supports multilevel inheritance or multiple inheritance ? And Why ?
	JavaScript supports multilevel inheritance but not multiple inheritance. Multilevel inheritance involves creating a chain of classes where a subclass inherits from a superclass, and another subclass inherits from the first subclass. Multiple inheritance, inheriting from multiple classes, isn't directly supported to avoid complexities and conflicts in the language design.

#### What is function overloading and function overriding ?
---

### ✅ **Function Overloading**  
- **Definition**: Multiple functions with the **same name but different parameters** (number or type).  
- **JavaScript** **does not support** real overloading like Java/C++.  
- But you can **simulate** it using `arguments` or default parameters.

#### Example (simulated in JS):
```js
function greet(name) {
  console.log("Hello " + name);
}

function greet() {
  console.log("Hello World");
}

greet("Alice"); // Only last function is used — no real overloading
```

🧠 In JS, the last defined function overrides earlier ones.

---

### ✅ **Function Overriding**  
- **Definition**: A **child class provides a new version** of a method that was defined in the parent class.  
- Used in **inheritance** to customize behavior.

#### Example:
```js
class Animal {
  speak() {
    console.log("Animal sound");
  }
}

class Dog extends Animal {
  speak() {
    console.log("Woof!");
  }
}

new Dog().speak(); // Woof!
```

✅ **Overriding** replaces the inherited method in the subclass.

---




















#### What are the four pillars of OOPS ? 

	**Four Pillars of OOPS in JS:**
	1. **Encapsulation:** Bundling data and methods that operate on the data within a single unit, often a class or object.
	2. **Abstraction:** Hiding complex implementation details and exposing only essential features.
	3. **Inheritance:** Sharing properties and methods between classes.
	4. **Polymorphism:** Objects can take on multiple forms, using the same method name for different behaviors.


#### What is the uses of super keyword ?

	The `super` keyword in JavaScript is used to call methods from the parent class in a subclass. It helps access and extend functionalities from the superclass. Example:

	```javascript
	class Animal {
	  speak() {
	    return "Animal sound";
	  }
	}

	class Dog extends Animal {
	  speak() {
	    return super.speak() + ", Bark!";
	  }
	}

	const myDog = new Dog();
	console.log(myDog.speak());  // Output: "Animal sound, Bark!"
	```

	In JavaScript, the `super` keyword is often used inside the constructor of a subclass to call the constructor of its parent class. This is necessary to properly initialize the object created by the subclass.

	When a subclass has its own constructor, it needs to call the constructor of the parent class using `super()` to ensure that the initialization logic in the parent class is executed. This helps in setting up the inherited properties and performing any additional setup required by the parent class.

	Here's an example:

	```javascript
	class Animal {
	  constructor(name) {
	    this.name = name;
	  }
	}

	class Dog extends Animal {
	  constructor(name, breed) {
	    super(name); // Calling the constructor of the parent class
	    this.breed = breed;
	  }

	  getDescription() {
	    return `${this.name} is a ${this.breed} dog.`;
	  }
	}

	const myDog = new Dog('Buddy', 'Labrador');
	console.log(myDog.getDescription());  // Output: "Buddy is a Labrador dog."
	```

	In this example, `super(name)` ensures that the `name` property is properly initialized by calling the constructor of the `Animal` class. This way, the `Dog` class can extend the functionality of the `Animal` class while properly initializing its own properties.

#### What is shadowing and illegal shadowing ?

	**Shadowing in JS:**
	Shadowing occurs when a variable declared in an inner scope has the same name as a variable in an outer scope, temporarily hiding the outer variable within that scope.

	**Illegal Shadowing:**
	Illegal shadowing happens when a variable is unintentionally shadowed, leading to unexpected behavior and potential bugs in the code.


#### simply explain with example what is curring and what is infinite curring, and use of curring



	**Currying:**
	Currying is a technique in functional programming where a function with multiple arguments is transformed into a sequence of functions, each taking a single argument.

	Example:
	```javascript
	function curryAdd(a) {
	  return function(b) {
	    return a + b;
	  };
	}
	const add5 = curryAdd(5);
	console.log(add5(3));  // Output: 8
	```

	**Infinite Currying:**
	Infinite currying refers to extending currying to handle an arbitrary number of arguments.

	Example:
	```javascript
	function infiniteCurry(initial) {
	  const curry = (next) => infiniteCurry(initial + next);
	  curry.toString = () => initial;
	  return curry;
	}

	const result = infiniteCurry(1)(2)(3)(4); 
	console.log(result.toString());  // Output: 10

	```
	**Function Currying Use:**
	Currying allows functions to be partially applied, creating new functions with predefined arguments. It enhances code reusability, readability, and supports building more specialized functions by fixing some parameters while leaving others flexible.

	Example:
	```javascript
	function curryAdd(a) {
	  return function(b) {
	    return a + b;
	  };
	}
	const add5 = curryAdd(5);
	console.log(add5(3));  // Output: 8
	```



#### What are polyfills ?

	Polyfills in JavaScript: Polyfills are code snippets or scripts that provide modern functionality to older browsers that lack support for certain features or methods. They fill the gaps by emulating or adding missing functionalities, enabling web developers to write code that works consistently across different browsers.

#### What is pure and impure function ?
	Pure Function: A pure function in JavaScript always produces the same output for the same input, without modifying external state or causing side effects. It's predictable, making code more reliable and easier to test.

	Impure Function: An impure function may have side effects, modifying external state or relying on mutable data. It can produce different outputs for the same input, making code less predictable and harder to reason about.


	**Pure Function in JS:**
	A pure function consistently produces the same output for the same input, has no side effects, and doesn't rely on external state.

	Example:
	```javascript
	function add(a, b) {
	  return a + b;
	}
	```

	**Impure Function in JS:**
	An impure function may have side effects or rely on external state, leading to unpredictable behavior.

	Example:
	```javascript
	let total = 0;
	function impureAdd(value) {
	  total += value;
	  return total;
	}
	```


#### in browser setTimeout goes to the web api until it takes given time, but where does it go in case of nodejs, simply explain in 50 words

	In Node.js, `setTimeout` doesn't go to a Web API as in the browser. Instead, it utilizes the event loop and the timer functions provided by the underlying environment. The timer is managed by the libuv library in Node.js, allowing for asynchronous execution while waiting for the specified time to elapse.


#### What is the use of Array.filter method in js

	The `array.filter` method in JavaScript is used to create a new array with elements that pass a specific test provided by a function. It helps filter out elements based on a given condition, creating a more refined subset of the original array.

	Example:
	```javascript
	const numbers = [1, 2, 3, 4, 5];

	const evenNumbers = numbers.filter(function(num) {
	  return num % 2 === 0;
	});

	console.log(evenNumbers);  // Output: [2, 4]
	```

	In this example, `array.filter` is used to create a new array (`evenNumbers`) containing only the even numbers from the original array (`numbers`).



#### What the hell are pure or static functions?When do we use it?
	No, static functions and pure functions are different concepts in JavaScript.

	- **Static Function:**
	  - A static function is associated with a class rather than an instance of the class.
	  - It can be called on the class itself, not on an instance.
	  - It may or may not be pure; the concept of being static or non-static is independent of whether the function is pure.

	Example of a static function:
	```javascript
	class MathOperations {
	  static add(a, b) {
	    return a + b;
	  }
	}

	const result = MathOperations.add(2, 3); // Calling the static function
	```

	- **Pure Function:**
	  - A pure function consistently produces the same output for the same input, has no side effects, and doesn't rely on external state.
	  - Pure functions are not necessarily static; they can be instance methods or regular functions.

	Example of a pure function:
	```javascript
	function add(a, b) {
	  return a + b;
	}
	```

	In summary, static functions refer to functions associated with a class, while pure functions refer to functions with specific characteristics regarding predictability, lack of side effects, and independence from external state. They are distinct concepts and may or may not overlap in a given codebase.

#### what is destructuring?
  Destructuring is a feature in JavaScript that allows us to extract data from arrays and objects. Instead of accessing each element of an array or each property of an object individually, we can use destructuring to extract the values we need and assign them to variables in a single statement. 

#### what is pure functions?
  A pure function is a function that always produces the same output for the same input and has no side effects. Here are the key characteristics of a pure function:

	1. Deterministic: Given the same input, a pure function will always produce the same output. It does not depend on any external state that may change over time.

	2. No Side Effects: A pure function does not modify or interact with external state or variables outside of its scope. It does not mutate input parameters or modify any global variables. The only result of calling a pure function is the computed return value.

	3. Referential Transparency: A pure function can be replaced with its return value without affecting the correctness of the program. This property allows for easy reasoning, testing, and composition of functions.

#### What is the difference between Js import snd require syntax

#### simply explain in 50 words with example what is parsing and give one example in js

	**Parsing in JS:**
	Parsing is the process of converting data from one format to another, often from a string to a different data type.

	Example in JavaScript:
	```javascript
	const numericString = "42";
	const numericValue = parseInt(numericString);
	console.log(numericValue);  // Output: 42
	```
	In this example, `parseInt` parses the string "42" into the numeric value 42.



#### What are classes in javascript?

  In javascript, classes are a way to define blueprints for creating objects with shared properties and methods. A class serves as a template for creating objects, and the objects created from a class are often referred to as instances. 
 
#### What are constructors? what does super() do in js?


	In javascript, a constructor is a special method that gets called when an instance of a class is created. It is used to initialize the properties and set up the initial state of the object. Constructors are defined within the class and are named constructor.

	The super() keyword is used inside a constructor when we are working with classes that inherit from another class. Inheritance allows a Childclass to inherit properties and methods from a parent class. When we call super() within a Childclass constructor, it calls the constructor of the parent class and allows us to initialize properties or perform setup specific to the parent class.

	The super() call is necessary when extending a class to ensure that the parent classs constructor is executed properly before initializing the Childclasss properties. It is a way to establish a relationship between the parent and child classes in terms of initialization and inheritance.


#### What are destructors? when are they called?

	JavaScript does not have a concept of "destructors" that are automatically called when an object goes out of scope or is no longer needed. Instead, js uses a garbage collector to manage memory and automatically reclaim memory from objects that are no longer reachable. When an object is no longer referenced by any variables or functions, it becomes eligible for garbage collection, and its memory will be freed up at some point by the js engine.


#### Explain garbage collection in js.? When is a variable garbage collected?

	Garbage collection is a process in javascript that automatically manages memory by identifying and cleaning up objects that are no longer reachable or needed by the program. This helps prevent memory leaks and ensures efficient memory usage in javascript applications. 

	the garbage collection process generally works in javascript as below:

	Mark and Sweep Algorithm: 
	The most common garbage collection algorithm used in javascript is the "mark and sweep" algorithm.

	Mark: The garbage collector starts by marking all the variables and objects that are still reachable from the root scope. This generally includes global variables and any variables that are currently in scope, such as local variables within executing functions.

	Sweep: After marking, the garbage collector then sweeps through the memory, looking for objects that were not marked during the first phase. These unmarked objects are considered unreachable and are candidates for removal from memory.

#### What is abstraction and encapsulation.

	Abstraction focuses on simplifying complex reality by representing essential features and ignoring unimportant details.

	Encapsulation involves bundling data and methods together, providing controlled access to the internal state of an object while hiding implementation details.


#### What is metadata
	Metadata is data that provides information about other data. It describes or gives details about a file or piece of content, like the author, date created, file size, or format. For example, in a photo, metadata could include 	the date it was taken, the camera used, and the location.


















# OBJECT ORIENTED PROGRAMMING





Sure! Here are some commonly asked JavaScript OOP (Object-Oriented Programming) interview questions:

Here’s a **simple explanation** for each question, perfect for taking quick notes:

---

### ✅ **1. What is Object-Oriented Programming in JavaScript?**

**Answer:**  
Object-Oriented Programming (OOP) is a way to structure code using **objects** that contain **data (properties)** and **functions (methods)**.  
In JavaScript, OOP allows you to build reusable and modular code using objects, classes, and inheritance.

> Think of objects like real-world things (e.g., a car has properties like color and methods like drive).

---

### ✅ **2. What are objects in JavaScript?**

**Answer:**  
Objects are **collections of key–value pairs**.  
Each key is called a **property name**, and the value can be data or a function.

Example:
```js
const car = {
  brand: "Toyota",
  speed: 120,
  drive: function() {
    console.log("Driving...");
  }
};
```

---

### ✅ **3. How do you create an object in JavaScript?**

**Answer:**  
There are multiple ways:

- **Object literal:**
  ```js
  const person = { name: "Alice", age: 30 };
  ```

- **Constructor function:**
  ```js
  function Person(name, age) {
    this.name = name;
    this.age = age;
  }
  const p1 = new Person("Bob", 25);
  ```

- **Class (ES6):**
  ```js
  class Person {
    constructor(name, age) {
      this.name = name;
      this.age = age;
    }
  }
  const p2 = new Person("Charlie", 28);
  ```

---

### ✅ **4. What is the difference between object literals and constructor functions?**

**Answer:**

| Feature                  | Object Literal                      | Constructor Function           |
|--------------------------|-------------------------------------|--------------------------------|
| Syntax                   | `{}` directly                       | Uses `function` + `new`        |
| Reusability              | Not reusable without copy           | Can create many instances      |
| Example                  | `const a = {x:1}`                   | `function A() { this.x = 1 }`  |

> Use literals for single objects, and constructors/classes for many similar objects.

---

### ✅ **5. What is `this` keyword in JavaScript?**

**Answer:**  
`this` refers to the **object that is currently calling the function**.

- Inside an object method, `this` refers to that object.
- Inside a function, it depends on how the function is called.

Example:
```js
const obj = {
  name: "JavaScript",
  sayHi: function() {
    console.log(this.name);
  }
};
obj.sayHi(); // "JavaScript"
```

> Tip: In arrow functions, `this` is **not bound** — it uses the outer context.

---

Let me know if you want intermediate-level questions explained next!

Here’s a **simple and note-friendly explanation** for each **intermediate-level OOP question** in JavaScript:

---

### ✅ **6. What is a prototype in JavaScript?**

**Answer:**  
A **prototype** is an object that other objects can inherit properties and methods from.

Every function in JavaScript has a `.prototype` property, which is used when creating new objects via constructor functions or classes.

Example:
```js
function Person(name) {
  this.name = name;
}
Person.prototype.greet = function() {
  console.log("Hello, " + this.name);
};
const p = new Person("Alice");
p.greet(); // Hello, Alice
```

> Think of it as a chain: if something is not found on the object, JavaScript looks in its prototype.

---

### ✅ **7. What are constructor functions and how are they used?**

**Answer:**  
A **constructor function** is a regular function used to create multiple objects with the same structure.

- Use `function Name() { ... }`
- Call it using `new` keyword.

Example:
```js
function Car(brand) {
  this.brand = brand;
}
const myCar = new Car("Toyota");
```

> The `new` keyword automatically sets `this` and links the object to the constructor’s prototype.

---

### ✅ **8. How does inheritance work in JavaScript?**

**Answer:**  
Inheritance in JavaScript means one object can access properties/methods of another using the **prototype chain**.

Two main ways:
- **Before ES6** – using `Object.create()` or setting `__proto__`
- **ES6+** – using `class` and `extends`

Example (ES6):
```js
class Animal {
  speak() {
    console.log("Animal sound");
  }
}
class Dog extends Animal {
  speak() {
    console.log("Bark!");
  }
}
const d = new Dog();
d.speak(); // Bark!
```

---

### ✅ **9. What is the difference between `__proto__` and `prototype`?**

| Feature          | `__proto__`                          | `.prototype`                          |
|------------------|--------------------------------------|----------------------------------------|
| Belongs to       | Object instance                      | Constructor function                   |
| Used for         | Accessing the object's prototype     | Defines properties shared by instances |
| Editable?        | Yes (not recommended)                | Yes                                    |

Example:
```js
function A() {}
const obj = new A();

obj.__proto__ === A.prototype; // true
```

> `__proto__` is the *actual* prototype link; `prototype` is where that link is defined.

---

### ✅ **10. How can you implement inheritance using ES6 classes?**

**Answer:**  
Use `class` and `extends` keywords to create a child class from a parent class.

Example:
```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(this.name + " makes a sound");
  }
}

class Cat extends Animal {
  speak() {
    console.log(this.name + " meows");
  }
}

const c = new Cat("Milo");
c.speak(); // Milo meows
```

> `extends` automatically links the child class to the parent prototype.

---

Let me know if you’d like **advanced-level** questions simplified next!


Here's a **simple, note-friendly explanation** of each **Advanced-Level JavaScript OOP question**, perfect for quick review or presentation:

---

### ✅ **11. What is the difference between classical and prototypal inheritance?**

| Feature               | Classical Inheritance            | Prototypal Inheritance                  |
|-----------------------|----------------------------------|-----------------------------------------|
| Found in languages like | Java, C++                       | JavaScript                              |
| Structure             | Classes and subclasses           | Objects inherit from other objects      |
| Instantiation         | Use `new` with class             | Use `Object.create()` or `__proto__`    |
| Flexibility           | Rigid (fixed structure)          | Flexible and dynamic                    |

**JavaScript supports prototypal inheritance** by default, but with `class` syntax (since ES6), it looks classical for ease of use.

---

### ✅ **12. What are mixins in JavaScript?**

**Answer:**  
**Mixins** are a way to **share reusable functionality** between objects or classes **without using inheritance**.

They are simple objects or functions that inject methods/properties.

**Example:**
```js
let canFly = {
  fly() {
    console.log("Flying");
  }
};

let canSwim = {
  swim() {
    console.log("Swimming");
  }
};

class Duck {}
Object.assign(Duck.prototype, canFly, canSwim);

const d = new Duck();
d.fly();  // Flying
d.swim(); // Swimming
```

> Think of mixins like adding skills to an object — e.g., a duck can both fly and swim.

---

### ✅ **13. What are private and public members in JavaScript classes?**

**Answer:**

- **Public members** can be accessed anywhere (default).
- **Private members** (since ES2020) start with `#` and can only be accessed inside the class.

**Example:**
```js
class User {
  #password; // private
  constructor(name, password) {
    this.name = name;       // public
    this.#password = password;
  }

  getPassword() {
    return this.#password;
  }
}

const u = new User("John", "secret");
console.log(u.name);           // John
console.log(u.getPassword()); // secret
// console.log(u.#password);  // ❌ Syntax error
```

> Private fields are safer for sensitive data.

---

### ✅ **14. How do getters and setters work in JavaScript?**

**Answer:**
- `get` lets you define a method that looks like a property.
- `set` lets you run logic when a property is assigned.

**Example:**
```js
class Circle {
  constructor(radius) {
    this._radius = radius;
  }

  get area() {
    return Math.PI * this._radius ** 2;
  }

  set radius(r) {
    if (r > 0) this._radius = r;
  }
}

const c = new Circle(5);
console.log(c.area); // 78.54
c.radius = 10;
console.log(c.area); // 314.15
```

> `get`/`set` allow encapsulation — logic behind properties.

---

### ✅ **15. How does method overriding work in JavaScript?**

**Answer:**
**Method overriding** is when a subclass defines a method with the **same name as its parent**, replacing it.

**Example:**
```js
class Animal {
  speak() {
    console.log("Animal speaks");
  }
}

class Dog extends Animal {
  speak() {
    console.log("Dog barks");
  }
}

const d = new Dog();
d.speak(); // Dog barks
```

> You can also call the parent method using `super()`:
```js
class Dog extends Animal {
  speak() {
    super.speak();
    console.log("...then Dog barks");
  }
}
```

---



---

Here are **clear, simple answers** to the **Core OOP Concepts in JavaScript**, great for notes or presentations:

---

### ✅ 1. **Explain the four pillars of OOP and how they apply in JavaScript**

| Pillar           | Meaning | JavaScript Example |
|------------------|--------|--------------------|
| **Encapsulation** | Keep internal data hidden | Use closures or `#private` fields |
| **Abstraction**   | Show only necessary details | Classes hide complex logic behind methods |
| **Inheritance**   | Reuse code across objects | Via prototypes or ES6 `extends` |
| **Polymorphism**  | Same method, different behavior | Method overriding in subclasses |

**Example (Polymorphism):**
```js
class Animal {
  speak() { console.log("Animal speaks"); }
}
class Dog extends Animal {
  speak() { console.log("Dog barks"); }
}
```

---

### ✅ 2. **What’s the difference between `Object.create()` and using the `new` keyword?**

| Feature              | `Object.create()`                        | `new` keyword                       |
|----------------------|------------------------------------------|-------------------------------------|
| Inheritance Method   | Sets prototype directly                  | Uses constructor function/class     |
| Constructor Called?  | ❌ No constructor called                 | ✅ Constructor is called            |
| Use Case             | Fine-grained prototype setup              | Creating instances with logic       |

**Example:**
```js
const animal = { eats: true };
const dog = Object.create(animal);
```

```js
function Animal() { this.eats = true; }
const dog = new Animal();
```

---

### ✅ 3. **How does JavaScript handle inheritance under the hood?**

JavaScript uses **prototypal inheritance**.

Each object has an internal link to another object called its **`[[Prototype]]`** (accessed via `__proto__`).

When accessing a property, JS looks up the prototype chain until it finds it or reaches `null`.

**Example:**
```js
const animal = { eats: true };
const dog = Object.create(animal);

console.log(dog.eats); // true (inherited)
```

---

### ✅ 4. **Can you explain the prototype chain and how property lookup works?**

**Answer:**  
When you try to access a property on an object:
1. JS first looks on the object itself.
2. If not found, it checks `__proto__`.
3. This continues up the **prototype chain**.
4. If it reaches `null` (top of chain), it returns `undefined`.

**Example:**
```js
const grandparent = { hasCar: true };
const parent = Object.create(grandparent);
const child = Object.create(parent);

console.log(child.hasCar); // true (inherited from grandparent)
```

> Think of the prototype chain like a family tree for properties.

---

### ✅ 5. **What happens if you add a method to `Object.prototype`?**

It becomes available on **all objects** — even ones you didn’t touch.

**Example:**
```js
Object.prototype.sayHi = function () {
  console.log("Hi from " + this.constructor.name);
};

const obj = {};
obj.sayHi(); // Hi from Object
```

⚠️ **But:**  
Modifying `Object.prototype` is dangerous:
- It affects all objects.
- Can break loops or libraries.
- Not recommended in production.

---


---
Absolutely! Here are **simple, note-friendly answers** for the **ES6 Classes vs Prototypes** section of JavaScript OOP:

---

### ✅ 6. **How are ES6 classes just syntactic sugar over prototypes?**

ES6 classes **look cleaner** but internally use the **same prototype system**.

When you write:
```js
class Person {
  speak() { console.log("Hi"); }
}
```
JavaScript translates it to:
```js
function Person() {}
Person.prototype.speak = function() {
  console.log("Hi");
};
```

📌 **Syntactic sugar** means: prettier way to write the same old thing.

---

### ✅ 7. **What’s the difference between instance methods and prototype methods in classes?**

| Type               | Lives Where                  | Created For Each Object? |
|--------------------|------------------------------|---------------------------|
| **Instance method** | Inside constructor (e.g., `this.run = ...`) | ✅ Yes |
| **Prototype method** | Defined outside constructor (e.g., `run() {}` in class) | ❌ No (shared) |

✅ **Best practice**: Use prototype methods for shared logic (saves memory).

---

### ✅ 8. **Can you override a parent class method in JavaScript? How?**

Yes! Simply define the **same method name** in the child class.

**Example:**
```js
class Animal {
  speak() { console.log("Animal speaks"); }
}

class Dog extends Animal {
  speak() { console.log("Dog barks"); } // overrides parent method
}
```

✔️ This is **polymorphism** – same method, different behavior.

---

### ✅ 9. **Explain the role of `super()` in class inheritance.**

- `super()` is used in child constructors to call the **parent constructor**.
- Also used to call **parent methods** inside overridden methods.

**Example:**
```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() { console.log(this.name + " makes a noise"); }
}

class Dog extends Animal {
  constructor(name) {
    super(name); // calls Animal's constructor
  }
  speak() {
    super.speak(); // calls Animal's speak
    console.log(this.name + " barks");
  }
}
```

🧠 Without `super()`, `this` won't work inside child constructor.

---

### ✅ 10. **How do static methods differ from instance methods in ES6 classes?**

| Feature             | **Static Methods**                        | **Instance Methods**             |
|---------------------|-------------------------------------------|----------------------------------|
| Called On           | The class itself                          | The object (instance)            |
| Access to `this`?   | Refers to the class                       | Refers to the object             |
| Use Case            | Utility functions, factories              | Behavior of the object           |

**Example:**
```js
class MathHelper {
  static add(a, b) { return a + b; }
}
console.log(MathHelper.add(2, 3)); // 5
```

🧠 You **can’t call** a static method from an instance:
```js
const m = new MathHelper();
m.add(2, 3); // ❌ Error
```

---

---

Here are **simple, easy-to-remember answers** for the **Encapsulation & Privacy** section in JavaScript:

---

### ✅ 11. **How can you implement private properties in JavaScript (ES6+ and legacy)?**

There are **3 common ways** to create private properties:

| Method                     | Description                         | Supported In      |
|----------------------------|-------------------------------------|-------------------|
| `#privateField`            | Real private field (hard privacy)   | ES2022+           |
| `WeakMap` or `Symbol`      | Hacky but effective workaround      | All modern JS     |
| **Closures**               | Old-school private variables        | Always supported  |

✅ **Modern way (recommended):**
```js
class User {
  #password; // private field
  constructor(pwd) {
    this.#password = pwd;
  }
  checkPassword(pwd) {
    return this.#password === pwd;
  }
}
```

---

### ✅ 12. **Explain the use of `#` (private fields) in JavaScript classes.**

- Fields starting with `#` are **truly private**.
- Only accessible **inside the class** — not even from `this`.

**Example:**
```js
class BankAccount {
  #balance = 0;

  deposit(amount) {
    this.#balance += amount;
  }

  getBalance() {
    return this.#balance;
  }
}
```

🚫 Accessing `account.#balance` from outside throws an error.

✔️ **# fields provide hard privacy** — better than naming things `_private`.

---

### ✅ 13. **How can closures be used to simulate private variables?**

Closures **trap variables** inside a function scope — so no outside code can access them.

**Example using function and closure:**
```js
function createCounter() {
  let count = 0; // private

  return {
    increment() { count++; },
    getCount() { return count; }
  };
}

const counter = createCounter();
counter.increment();
console.log(counter.getCount()); // 1
```

🧠 Here, `count` is **truly private** — you can’t access or modify it directly.

---

Would you like a visual cheat sheet of all OOP privacy patterns as a quick-ref?


---

Here are **simple, easy-to-remember answers** for the **Polymorphism & Abstraction** section in JavaScript OOP:

---

### ✅ 14. **How does JavaScript support polymorphism without traditional method overloading?**

JavaScript **doesn't have built-in method overloading** like Java or C#, but it supports **polymorphism** in flexible ways:

#### ✔️ How it works:
- In JS, **functions can accept any number of arguments**.
- You write logic to **handle different input types or lengths** manually.

**Example:**
```js
class Printer {
  print(msg) {
    if (typeof msg === "string") {
      console.log("Text:", msg);
    } else if (typeof msg === "object") {
      console.log("Object:", JSON.stringify(msg));
    }
  }
}

const p = new Printer();
p.print("Hello");      // Text
p.print({ name: "A" }); // Object
```

🧠 This is **polymorphism by dynamic typing** — one method behaves differently based on argument type.

---

### ✅ 15. **Can you simulate abstract classes or interfaces in JavaScript?**

JavaScript doesn’t have built-in `abstract` or `interface` keywords, but you can **simulate** them.

#### ✔️ Ways to simulate abstraction:

**(A) Manual pattern:**
```js
class Animal {
  makeSound() {
    throw new Error("makeSound() must be implemented");
  }
}
class Dog extends Animal {
  makeSound() {
    console.log("Woof!");
  }
}
```

- `Animal` is like an abstract class — it defines a method but expects subclass to implement it.
- If `Dog` forgets to implement `makeSound()`, it will crash at runtime.

**(B) JSDoc + TypeScript (optional):**
- In large teams, TypeScript is used to **enforce interfaces or abstract methods statically**.

---

✅ Summary:

| Concept       | How JavaScript Does It                        |
|---------------|-----------------------------------------------|
| Polymorphism  | Dynamic types, flexible method logic          |
| Abstraction   | Throw errors in base class; TS or docs help   |

Would you like a cheat sheet of all OOP features in JS together?
---

Here are **easy-to-remember answers with examples** for the **Real-World Scenarios** section of JavaScript OOP:

---

### ✅ 16. **How would you implement a Singleton pattern in JavaScript?**

A **Singleton** ensures only one instance of a class exists.

#### ✔️ Example:
```js
class Singleton {
  constructor() {
    if (Singleton.instance) return Singleton.instance;
    Singleton.instance = this;
    this.id = Math.random(); // Just for demo
  }
}

const a = new Singleton();
const b = new Singleton();
console.log(a === b); // true — same instance
```

🧠 Useful when you need one shared object, like config, DB connection, etc.

---

### ✅ 17. **Design a class-based module that restricts access to certain methods.**

You can use **private fields** (`#`) in ES6+ to hide methods.

#### ✔️ Example:
```js
class BankAccount {
  #balance = 0;

  deposit(amount) {
    if (amount > 0) this.#balance += amount;
  }

  #logTransaction() {
    console.log("Transaction logged");
  }

  getBalance() {
    this.#logTransaction(); // Can call private inside
    return this.#balance;
  }
}

const acc = new BankAccount();
// acc.#balance or acc.#logTransaction() → ❌ Error
```

✅ Good for **encapsulation** and protecting logic from outside changes.

---

### ✅ 18. **Can you write a class-based event emitter system (like Node.js EventEmitter)?**

Yes, you can create a simple **event pub/sub system**:

#### ✔️ Example:
```js
class EventEmitter {
  constructor() {
    this.events = {};
  }

  on(event, listener) {
    this.events[event] ||= [];
    this.events[event].push(listener);
  }

  emit(event, data) {
    (this.events[event] || []).forEach(fn => fn(data));
  }
}

const emitter = new EventEmitter();
emitter.on("data", d => console.log("Received:", d));
emitter.emit("data", { msg: "Hello" }); // Received: { msg: 'Hello' }
```

🎯 Used in UIs, logging, and real-time features.

---

### ✅ 19. **What are the downsides of deep prototype chains in performance?**

#### ❗ Issues:
- **Longer property lookup time**: JS engine walks up the prototype chain until it finds a property.
- **Harder to debug**: Errors may come from inherited levels.
- **Memory leaks**: If not managed well, long chains can retain references.

🧠 Keep inheritance shallow when possible. Favor **composition over deep inheritance**.

---

### ✅ 20. **How can you prevent an object from being modified (immutability)?**

You can **freeze or seal** an object:

#### ✔️ Example:
```js
const config = Object.freeze({
  apiKey: "12345",
  timeout: 5000,
});

config.apiKey = "99999"; // ❌ Won’t change
console.log(config.apiKey); // Still 12345
```

| Method            | Effect                          |
|-------------------|----------------------------------|
| `Object.freeze()` | Prevents any changes (full lock) |
| `Object.seal()`   | Prevents adding/removing props   |

Also, use **`const` + immutability patterns** to avoid state mutation.

---

Would you like me to bundle these 20 answers into a printable PDF cheat sheet too?















